type: edu
files:
- name: build.gradle
  visible: true
  text: |-
    plugins {
        id 'java'
        id 'org.springframework.boot' version '2.3.1.RELEASE'
        id 'io.spring.dependency-management' version '1.0.9.RELEASE'
    }

    repositories {
        mavenCentral()
    }

    sourceSets.main.resources.srcDirs = ["src/resources"]

    dependencies {
        implementation 'org.springframework.boot:spring-boot-starter'
        implementation 'org.springframework.boot:spring-boot-starter-actuator'
        implementation 'org.springframework.boot:spring-boot-starter-web'
        implementation group: 'org.hibernate', name: 'hibernate-validator', version: '6.1.0.Final'
    }
  learner_created: false
- name: src/account/AccountServiceApplication.java
  visible: true
  text: |-
    package account;

    import org.springframework.boot.SpringApplication;
    import org.springframework.boot.autoconfigure.SpringBootApplication;

    @SpringBootApplication
    public class AccountServiceApplication {

        public static void main(String[] args) {
            SpringApplication.run(AccountServiceApplication.class, args);
        }

    }
  learner_created: false
- name: src/resources/application.properties
  visible: true
  text: |-
    server.port=28852
    management.endpoints.web.exposure.include=*
    management.endpoint.shutdown.enabled=true
    spring.jackson.serialization.INDENT_OUTPUT=true
  learner_created: false
- name: test/AccountServiceTest.java
  visible: false
  text: |-
    import account.AccountServiceApplication;
    import com.fasterxml.jackson.annotation.JsonInclude;
    import com.fasterxml.jackson.core.JsonProcessingException;
    import com.fasterxml.jackson.databind.ObjectMapper;
    import com.google.gson.JsonArray;
    import com.google.gson.JsonElement;
    import com.google.gson.JsonObject;
    import com.google.gson.JsonParser;
    import org.hyperskill.hstest.dynamic.DynamicTest;
    import org.hyperskill.hstest.dynamic.input.DynamicTesting;
    import org.hyperskill.hstest.exception.outcomes.UnexpectedError;
    import org.hyperskill.hstest.mocks.web.response.HttpResponse;
    import org.hyperskill.hstest.stage.SpringTest;
    import org.hyperskill.hstest.testcase.CheckResult;

    import java.util.ArrayList;
    import java.util.LinkedHashMap;
    import java.util.List;
    import java.util.Map;
    import java.util.stream.Collectors;

    import static org.hyperskill.hstest.common.JsonUtils.getJson;
    import static org.hyperskill.hstest.common.JsonUtils.getPrettyJson;
    import static org.hyperskill.hstest.testing.expect.Expectation.expect;
    import static org.hyperskill.hstest.testing.expect.json.JsonChecker.*;

    class TestReq {

        private Map<String, Object> properties = new LinkedHashMap<>();

        // Deep copy
        public TestReq(TestReq another) {
            this.properties = another.properties.entrySet().stream()
                    .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
        }

        public TestReq() {
        }

        public String toJson() {
            ObjectMapper mapper = new ObjectMapper();
            mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
            try {
                return mapper.writeValueAsString(this.properties);
            } catch (JsonProcessingException e) {
                System.out.println(e.getMessage());
                return null;
            }
        }

        public TestReq setProps(String key, Object value) {
            properties.put(key, value);
            return this;
        }

    }

    public class AccountServiceTest extends SpringTest {

        private  final String signUpApi = "/api/auth/signup";
        private  final String changePassApi = "/api/auth/changepass";
        private  final String getEmployeePaymentApi = "/api/empl/payment";
        private final String postPaymentApi = "api/acct/payments";


        static String[] breachedPass= new String[]{"PasswordForJanuary", "PasswordForFebruary", "PasswordForMarch",
                "PasswordForApril", "PasswordForMay", "PasswordForJune",
                "PasswordForJuly", "PasswordForAugust", "PasswordForSeptember",
                "PasswordForOctober", "PasswordForNovember", "PasswordForDecember"};

        List<Integer> userIdList = new ArrayList<>();

        private final TestReq johnDoe = new TestReq().setProps("name", "John")
                .setProps("lastname", "Doe")
                .setProps("email", "JohnDoe@acme.com")
                .setProps("password", "oMoa3VvqnLxW");
        private final TestReq maxMus = new TestReq().setProps("name", "Max")
                .setProps("lastname", "Mustermann")
                .setProps("email", "MaxMustermann@acme.com")
                .setProps("password", "ai0y9bMvyF6G");
        private final TestReq captainNemo = new TestReq().setProps("name", "Captain")
                .setProps("lastname", "Nemo")
                .setProps("email", "nautilus@pompilius.com")
                .setProps("password", "wings");

        private final String jDCorrectUser = johnDoe.toJson();
        private final String jDEmptyName = new TestReq(johnDoe).setProps("name", "").toJson();
        private final String jDNoName = new TestReq(johnDoe).setProps("name", null).toJson();
        private final String jDEmptyLastName = new TestReq(johnDoe).setProps("lastname", "").toJson();
        private final String jDNoLastName = new TestReq(johnDoe).setProps("lastname", null).toJson();
        private final String jDEmptyEmail = new TestReq(johnDoe).setProps("email", "").toJson();
        private final String jDNoEmail = new TestReq(johnDoe).setProps("email", null).toJson();
        private final String jDEmptyPassword = new TestReq(johnDoe).setProps("password", "").toJson();
        private final String jDNoPassword = new TestReq(johnDoe).setProps("password", null).toJson();
        private final String jDWrongEmail1 = new TestReq(johnDoe).setProps("email", "johndoeacme.com").toJson();
        private final String jDWrongEmail2 = new TestReq(johnDoe).setProps("email", "johndoe@google.com").toJson();
        private final String maxMusCorrectUser = maxMus.toJson();
        private final String jDLower = new TestReq(johnDoe).setProps("email", "johndoe@acme.com").toJson();
        private final String maxMusLower = new TestReq(maxMus).setProps("email", "maxmustermann@acme.com").toJson();
        private final String jDWrongPassword = new TestReq(johnDoe).setProps("password", "none").toJson();
        private final String maxMusWrongPassword = new TestReq(maxMus).setProps("password", "none").toJson();
        private final String captainNemoWrongUser = captainNemo.toJson();
        private final String jDNewPass = new TestReq(johnDoe).setProps("password", "aNob5VvqzRtb").toJson();

        private final String jDDuplicatePass = new TestReq().setProps("new_password", "oMoa3VvqnLxW").toJson();
        private final String jDShortPass = new TestReq().setProps("new_password", "oMoa3Vvqn").toJson();
        private final String jDPass = new TestReq().setProps("new_password", "aNob5VvqzRtb").toJson();

        private String paymentsList = convert(new String[]{
                new TestReq().setProps("employee", "johndoe@acme.com").setProps("period", "01-2021")
                        .setProps("salary", 123456).toJson(),
                new TestReq().setProps("employee", "johndoe@acme.com").setProps("period", "02-2021")
                        .setProps("salary", 456789).toJson(),
                new TestReq().setProps("employee", "johndoe@acme.com").setProps("period", "03-2021")
                        .setProps("salary", 12).toJson(),
                new TestReq().setProps("employee", "maxmustermann@acme.com").setProps("period", "01-2021")
                        .setProps("salary", 54321).toJson(),
                new TestReq().setProps("employee", "maxmustermann@acme.com").setProps("period", "02-2021")
                        .setProps("salary", 987654).toJson(),
                new TestReq().setProps("employee", "maxmustermann@acme.com").setProps("period", "03-2021")
                        .setProps("salary", 120).toJson()
        });
        private String wrongPaymentListData = convert(new String[]{new TestReq().setProps("employee", "johndoe@acme.com")
                .setProps("period", "13-2021").setProps("salary", 123456).toJson()});


        private  String wrongPaymentListSalary = convert(new String[]{new TestReq().setProps("employee", "johndoe@acme.com")
                .setProps("period", "13-2021").setProps("salary", -1).toJson()});

        private String wrongPaymentListDuplicate = convert(new String[]{
                new TestReq().setProps("employee", "johndoe@acme.com").setProps("period", "01-2021")
                        .setProps("salary", 123456).toJson(),
                new TestReq().setProps("employee", "johndoe@acme.com").setProps("period", "01-2021")
                        .setProps("salary", 456789).toJson()
        });
        private String updatePayment = new TestReq().setProps("employee", "johndoe@acme.com").setProps("period", "01-2021")
                .setProps("salary", 77777).toJson();
        private String updatePayment1 = new TestReq().setProps("employee", "johndoe@acme.com").setProps("period", "01-2021")
                .setProps("salary", 88777).toJson();
        private String updatePaymentResponse = new TestReq().setProps("name", "John").setProps("lastname", "Doe")
                .setProps("period", "January-2021").setProps("salary", "777 dollar(s) 77 cent(s)").toJson();
        private String updatePaymentResponse1 = new TestReq().setProps("name", "John").setProps("lastname", "Doe")
                .setProps("period", "January-2021").setProps("salary", "887 dollar(s) 77 cent(s)").toJson();
        private String updatePaymentWrongDate = new TestReq().setProps("employee", "johndoe@acme.com")
                .setProps("period", "13-2021").setProps("salary", 1234567).toJson();
        private String updatePaymentWrongSalary = new TestReq().setProps("employee", "johndoe@acme.com")
                .setProps("period", "13-2021").setProps("salary", -1).toJson();
        private String correctPaymentResponse = convert(new String[]{
                new TestReq().setProps("name", "John").setProps("lastname", "Doe")
                        .setProps("period", "March-2021").setProps("salary", "0 dollar(s) 12 cent(s)").toJson(),
                new TestReq().setProps("name", "John").setProps("lastname", "Doe")
                        .setProps("period", "February-2021").setProps("salary", "4567 dollar(s) 89 cent(s)").toJson(),
                new TestReq().setProps("name", "John").setProps("lastname", "Doe")
                        .setProps("period", "January-2021").setProps("salary", "1234 dollar(s) 56 cent(s)").toJson()
        });
        private String correctPaymentResponse1 = convert(new String[]{
                new TestReq().setProps("name", "John").setProps("lastname", "Doe")
                        .setProps("period", "March-2021").setProps("salary", "0 dollar(s) 12 cent(s)").toJson(),
                new TestReq().setProps("name", "John").setProps("lastname", "Doe")
                        .setProps("period", "February-2021").setProps("salary", "4567 dollar(s) 89 cent(s)").toJson(),
                new TestReq().setProps("name", "John").setProps("lastname", "Doe")
                        .setProps("period", "January-2021").setProps("salary", "777 dollar(s) 77 cent(s)").toJson()
        });
        private String correctPaymentResponse2 = convert(new String[]{
                new TestReq().setProps("name", "John").setProps("lastname", "Doe")
                        .setProps("period", "March-2021").setProps("salary", "0 dollar(s) 12 cent(s)").toJson(),
                new TestReq().setProps("name", "John").setProps("lastname", "Doe")
                        .setProps("period", "February-2021").setProps("salary", "4567 dollar(s) 89 cent(s)").toJson(),
                new TestReq().setProps("name", "John").setProps("lastname", "Doe")
                        .setProps("period", "January-2021").setProps("salary", "887 dollar(s) 77 cent(s)").toJson()
        });

        public AccountServiceTest() {
            super(AccountServiceApplication.class, "../service_db.mv.db");
        }

        private String convert(String[] trs) {
            JsonArray  jsonArray = new JsonArray();
            for (String tr : trs) {
                JsonElement jsonObject = JsonParser.parseString(tr);
                jsonArray.add(jsonObject);
            }
            return jsonArray.toString();
        }

        /**
         * Method for checking status code of response Post request for API
         *
         * @param api testing api (String)
         * @param body string representation of body content in JSON format (String)
         * @param status required http status for response (int)
         * @return instance of CheckResult class containing result of checks (CheckResult)
         */
        CheckResult testPostApi(String api, String body, int status, String message) {
            HttpResponse response = post(api, body).send();

            if (response.getStatusCode() != status) {
                return CheckResult.wrong("POST " + api + " should respond with "
                        + "status code " + status + ", responded: " + response.getStatusCode() + "\n"
                        + message + "\n"
                        + "Response body:\n" + response.getContent() + "\n"
                        + "Request body:\n" + body);
            }
            return CheckResult.correct();
        }

        CheckResult testPostApiWithAuth(String api, String body, int status, String login, String pass, String message) {
            HttpResponse response = post(api, body).basicAuth(login, pass).send();

            if (response.getStatusCode() != status) {
                return CheckResult.wrong("POST " + api + " should respond with "
                        + "status code " + status + ", responded: " + response.getStatusCode() + "\n"
                        + message + "\n"
                        + "Response body:\n" + response.getContent() + "\n"
                        + "Request body:\n" + body);
            }
            return CheckResult.correct();
        }

        /**
         * Method for checking status code of response Get request for API
         *
         * @param api testing api (String)
         * @param status required http status for response (int)
         * @param message hint about reason of error (String)
         * @return instance of CheckResult class containing result of checks (CheckResult)
         */
        CheckResult testGetApi(String api, int status, String message) {
            HttpResponse response = get(api).send();

            if (response.getStatusCode() != status) {
                return CheckResult.wrong("GET " + api + " should respond with "
                        + "status code " + status + ", responded: " + response.getStatusCode() + "\n"
                        + message);
            }
            return CheckResult.correct();
        }

        /**
         * Method for checking status code of response Get request for API
         *
         * @param api testing api (String)
         * @param status required http status for response (int)
         * @param message hint about reason of error (String)
         * @param login login
         * @param password password
         * @return instance of CheckResult class containing result of checks (CheckResult)
         */
        CheckResult testGetApiAuth(String api, int status, String login, String password, String message) {
            HttpResponse response = get(api).basicAuth(login, password).send();

            if (response.getStatusCode() != status) {
                return CheckResult.wrong("GET " + api + " should respond with "
                        + "status code " + status + ", responded: " + response.getStatusCode() + "\n"
                        + message);
            }
            return CheckResult.correct();
        }

        /**
         * Method for checking response on Post request for signup API
         *
         * @param body string representation of body content in JSON format (String)
         * @param status required http status for response (int)
         * @return instance of CheckResult class containing result of checks (CheckResult)
         */
        CheckResult testPostSignUpResponse(String body, int status) {
            HttpResponse response = post(signUpApi, body).send();
            testPostApi(signUpApi, body, status, "API must be available");

            JsonObject rightResponse = getJson(body).getAsJsonObject();
            rightResponse.remove("password");

            // Check is it JSON in response or something else
            if (!response.getJson().isJsonObject()) {
                return CheckResult.wrong("Wrong object in response, expected JSON but was \n" +
                        response.getContent().getClass());

            }

            JsonObject jsonResponse = response.getJson().getAsJsonObject();

            // Check if password is presence in response
            if (jsonResponse.get("password") != null) {
                return CheckResult.wrong("You must remove password from response\n" +
                        jsonResponse);
            }

            if (jsonResponse.get("id") == null) {
                return CheckResult.wrong("Response must contain user ID\n" +
                        "Received response:\n" +
                        jsonResponse);
            }

            // Check JSON in response
            expect(response.getContent()).asJson().check(
                    isObject()
                            .value("id", isInteger())
                            .value("name", rightResponse.get("name").getAsString())
                            .value("lastname", rightResponse.get("lastname").getAsString())
                            .value("email", isString(s -> s.equalsIgnoreCase(rightResponse.get("email").getAsString()))));

            if (userIdList.contains(jsonResponse.get("id").getAsInt())) {
                return CheckResult.wrong("User ID must be unique!\n" +
                        "Received response:\n" +
                        jsonResponse);
            }

            userIdList.add(jsonResponse.get("id").getAsInt());
            return CheckResult.correct();
        }


        /**
         * Method for restarting application
         *
         */
        private CheckResult restartApplication() {
            try {
                reloadSpring();
            } catch (Exception ex) {
                throw new UnexpectedError(ex.getMessage());
            }
            return CheckResult.correct();
        }

        /**
         * Method for checking authentication
         *
         * @param user string representation of user information in JSON format (String)
         * @param status required http status for response (int)
         * @param message hint about reason of error (String)
         * @return instance of CheckResult class containing result of checks (CheckResult)
         */
        private CheckResult testUserRegistration(String user, int status, String message) {
            JsonObject userJson = getJson(user).getAsJsonObject();
            String password = userJson.get("password").getAsString();
            String login = userJson.get("email").getAsString().toLowerCase();
            HttpResponse response = get(getEmployeePaymentApi).basicAuth(login, password).send();
            if (response.getStatusCode() != status) {
                return CheckResult.wrong("Get " + getEmployeePaymentApi + " should respond with "
                        + "status code " + status + ", responded: " + response.getStatusCode() + "\n"
                        + message + "\n"
                        + "Authentication with " + login + " / " + password);
            }
            return CheckResult.correct();
        }

        CheckResult testChangePassword(String api, String body, int status, String user) {
            JsonObject userJson = getJson(user).getAsJsonObject();
            String pass = userJson.get("password").getAsString();
            String login = userJson.get("email").getAsString().toLowerCase();
            HttpResponse response = post(api, body).basicAuth(login, pass).send();
            if (response.getStatusCode() != status) {
                return CheckResult.wrong("POST " + api + " should respond with "
                        + "status code " + status + ", responded: " + response.getStatusCode() + "\n"
                        + "Response body:\n" + response.getContent() + "\n"
                        + "Request body:\n" + body);
            }
            // Check JSON in response
            if (status == 200) {
                expect(response.getContent()).asJson().check(
                        isObject()
                                .value("email", userJson.get("email").getAsString().toLowerCase())
                                .value("status", "The password has been updated successfully"));
            }
            return CheckResult.correct();
        }

        /**
         * Method for testing duplicate users
         *
         * @param user string representation of user information in JSON format (String)
         * @return instance of CheckResult class containing result of checks (CheckResult)
         */
        private CheckResult testUserDuplicates(String user) {
            HttpResponse response = post(signUpApi, user).send();
            // Check error message field in JSON response
            expect(response.getContent()).asJson().check(
                    isObject()
                            .value("status", 400)
                            .value("error", "Bad Request")
                            .value("message", "User exist!")
                            .anyOtherValues());
            return CheckResult.correct();
        }

        private CheckResult testBreachedPass(String api, String login, String password, String body, String message) {
            JsonObject json = getJson(body).getAsJsonObject();
            HttpResponse response;
            for (int index = 0; index < breachedPass.length; index++) {
                if (json.has("password")) {
                    json.remove("password");
                    json.addProperty("password", breachedPass[index]);
                } else if (json.has("new_password")) {
                    json.remove("new_password");
                    json.addProperty("new_password", breachedPass[index]);
                }
                if (login.isEmpty() || password.isEmpty()) {
                    response = post(api, json.toString()).send();
                } else {
                    response = post(api, json.toString()).basicAuth(login, password).send();
                }

                if (response.getStatusCode() != 400) {
                    return CheckResult.wrong("POST " + api + " should respond with "
                            + "status code 400 , responded: " + response.getStatusCode() + "\n"
                            + "Response body:\n" + response.getContent() + "\n"
                            + "Request body:\n" + json + "\n"
                            + message);
                }
                expect(response.getContent()).asJson().check(
                        isObject()
                                .value("status", 400)
                                .value("error", "Bad Request")
                                .value("message", "The password is in the hacker's database!")
                                .anyOtherValues());

            }
            return CheckResult.correct();
        }


        CheckResult testPostPaymentResponse(String body, int status, String message) {
            HttpResponse response = post(postPaymentApi, body).send();
            if (response.getStatusCode() != status) {
                return CheckResult.wrong("POST " + postPaymentApi + " should respond with "
                        + "status code " + status + ", responded: " + response.getStatusCode() + "\n"
                        + message + "\n"
                        + "Response body:\n" + response.getContent() + "\n"
                        + "Request body:\n" + body);
            }

            // Check JSON in response
            if (response.getStatusCode() == 200) {
                expect(response.getContent()).asJson().check(
                        isObject()
                                .value("status", "Added successfully!")
                                .anyOtherValues());
            }
            if (response.getStatusCode() == 400) {
                expect(response.getContent()).asJson().check(
                        isObject()
                                .value("error", "Bad Request")
                                .value("path", "/api/acct/payments")
                                .value("status", 400)
                                .anyOtherValues());
            }
            return CheckResult.correct();
        }

        CheckResult testPutPaymentResponse(String body, int status, String message) {
            HttpResponse response = put(postPaymentApi, body).send();
            if (response.getStatusCode() != status) {
                return CheckResult.wrong("PUT " + postPaymentApi + " should respond with "
                        + "status code " + status + ", responded: " + response.getStatusCode() + "\n"
                        + message + "\n"
                        + "Response body:\n" + response.getContent() + "\n"
                        + "Request body:\n" + body);
            }

            // Check JSON in response
            if (response.getStatusCode() == 200) {
                expect(response.getContent()).asJson().check(
                        isObject()
                                .value("status", "Updated successfully!")
                                .anyOtherValues());
            }
            if (response.getStatusCode() == 400) {
                expect(response.getContent()).asJson().check(
                        isObject()
                                .value("error", "Bad Request")
                                .value("path", "/api/acct/payments")
                                .value("status", 400)
                                .anyOtherValues());
            }
            return CheckResult.correct();
        }

        CheckResult testGetPaymentResponse(String user, int status, String correctResponse, String message) {
            JsonObject userJson = getJson(user).getAsJsonObject();
            String password = userJson.get("password").getAsString();
            String login = userJson.get("email").getAsString().toLowerCase();
            HttpResponse response = get(getEmployeePaymentApi).basicAuth(login, password).send();

            // Check is it array of JSON in response or something else
            if (!response.getJson().isJsonArray()) {
                return CheckResult.wrong("Wrong object in response, expected array of JSON but was \n" +
                        response.getContent().getClass());

            }

            JsonArray correctJson = getJson(correctResponse).getAsJsonArray();
            JsonArray responseJson = getJson(response.getContent()).getAsJsonArray();

            if (response.getStatusCode() != status) {
                return CheckResult.wrong("POST " + getEmployeePaymentApi + " should respond with "
                        + "status code " + status + ", responded: " + response.getStatusCode() + "\n"
                        + message + "\n"
                        + "Response body:\n" + response.getContent() + "\n");
            }

            if (responseJson.size() == 0)  {
                return CheckResult.wrong("Payments was not added " + "\n"
                        + "endpoint " + getEmployeePaymentApi + "\n"
                        + "responded with " + getPrettyJson(responseJson)  + "\n"
                        + "must be " + getPrettyJson(correctJson));
            }

            if (correctJson.size() != responseJson.size()) {
                return CheckResult.wrong("New data should not be added" + "\n"
                        + "in response " + getPrettyJson(responseJson)  + "\n"
                        + "must be " + getPrettyJson(correctJson));
            }

            // Check JSON in response
            if (response.getStatusCode() == 200) {
                for (int i = 0; i < responseJson.size(); i++) {
                    if (!responseJson.get(i).equals(correctJson.get(i))) {
                        return CheckResult.wrong("Get " + getEmployeePaymentApi  +" wrong data in response body" + "\n"
                                + "in response " + getPrettyJson(responseJson) + "\n"
                                + "must be " + getPrettyJson(correctJson));
                    }
                }
            }

            return CheckResult.correct();
        }

        CheckResult testGetPaymentResponseParam(String user, int status, String request, String correctResponse, String message) {
            JsonObject userJson = getJson(user).getAsJsonObject();
            String password = userJson.get("password").getAsString();
            String login = userJson.get("email").getAsString().toLowerCase();
            JsonObject json = getJson(correctResponse).getAsJsonObject();
            JsonObject jsonRequest = getJson(request).getAsJsonObject();
            String param = jsonRequest.get("period").getAsString();
            HttpResponse response = get(getEmployeePaymentApi).addParam("period", param).basicAuth(login, password).send();

            if (response.getStatusCode() != status) {
                return CheckResult.wrong("GET " + getEmployeePaymentApi + "?period=" + param + " should respond with "
                        + "status code " + status + ", responded: " + response.getStatusCode() + "\n"
                        + message + "\n"
                        + "Response body:\n" + response.getContent() + "\n");
            }

            // Check JSON in response
            if (response.getStatusCode() == 200) {
                if (!response.getJson().equals(json)) {
                    return CheckResult.wrong("Get " + getEmployeePaymentApi  + "?period=" + param
                            + " wrong data in response body" + "\n"
                            + "in response " + getPrettyJson(response.getJson()) + "\n"
                            + "must be " + getPrettyJson(json));
                }
            }

            if (response.getStatusCode() == 400) {
                expect(response.getContent()).asJson().check(
                        isObject()
                                .value("error", "Bad Request")
                                .value("path", "/api/empl/payment")
                                .value("status", 400)
                                .anyOtherValues());
            }
            return CheckResult.correct();
        }

        @DynamicTest
        DynamicTesting[] dt = new DynamicTesting[] {
                // Test wrong POST request for signup api
                () -> testPostApi(signUpApi, jDEmptyName, 400, "Empty name field!"), // 1
                () -> testPostApi(signUpApi, jDNoName, 400, "Name field is absent!"), // 2
                () -> testPostApi(signUpApi, jDEmptyLastName, 400, "Empty lastname field!"), // 3
                () -> testPostApi(signUpApi, jDNoLastName, 400, "Lastname field is absent!"), // 4
                () -> testPostApi(signUpApi, jDEmptyEmail, 400, "Empty email field!"), // 5
                () -> testPostApi(signUpApi, jDNoEmail, 400, "Email field is absent!"), // 6
                () -> testPostApi(signUpApi, jDEmptyPassword, 400, "Empty password field!"), // 7
                () -> testPostApi(signUpApi, jDNoPassword, 400, "Password field is absent!"), // 8
                () -> testPostApi(signUpApi, jDWrongEmail1, 400, "Wrong email!"), // 9
                () -> testPostApi(signUpApi, jDWrongEmail2, 400, "Wrong email!"), // 10
                // Test user registration on signup api
                () -> testBreachedPass(signUpApi, "", "",
                        jDCorrectUser, "Sending password from breached list"), // 11
                () -> testPostSignUpResponse(jDCorrectUser, 200), // 12
                () -> testPostApi(signUpApi, jDCorrectUser, 400, "User must be unique!"), // 13
                () -> testUserDuplicates(jDCorrectUser), // 14
                () -> testPostApi(signUpApi, jDLower, 400, "User must be unique (ignorecase)!"), // 15
                () -> testPostSignUpResponse(maxMusLower, 200), // 16
                () -> testPostApi(signUpApi, maxMusLower, 400, "User must be unique!"), // 17
                () -> testPostApi(signUpApi, maxMusCorrectUser, 400, "User must be unique (ignorecase)!"), // 18
                // Test authentication, positive tests
                () -> testUserRegistration(jDLower, 200, "User must login!"), // 19
                () -> testUserRegistration(jDCorrectUser, 200, "Login case insensitive!"), // 20
                () -> testUserRegistration(maxMusLower, 200, "User must login!"), // 21
                () -> testUserRegistration(maxMusCorrectUser, 200, "Login case insensitive!"), // 22
                // Test authentication, negative tests
                () -> testUserRegistration(jDWrongPassword, 401, "Wrong password!"), // 23
                () -> testUserRegistration(jDWrongEmail1, 401, "Wrong user!"), // 24
                () -> testUserRegistration(maxMusWrongPassword, 401, "Wrong password!"), // 25
                () -> testUserRegistration(captainNemoWrongUser, 401, "Wrong user"), // 26
                () -> testGetApi(getEmployeePaymentApi, 401, "This api only for authenticated user"), // 27

                // Test changing password
                () -> testPostApi(changePassApi, jDDuplicatePass, 401, "This api only for authenticated user"), // 28
                () -> testPostApiWithAuth(changePassApi, jDShortPass, 400,
                        "JohnDoe@acme.com", "oMoa3VvqnLxW", "The password length must be at least 12 chars!"), // 29
                () -> testPostApiWithAuth(changePassApi, jDDuplicatePass, 400,
                        "JohnDoe@acme.com", "oMoa3VvqnLxW", "The passwords must be different!"), // 30
                () -> testBreachedPass(changePassApi, "JohnDoe@acme.com", "oMoa3VvqnLxW",
                        jDDuplicatePass, "Sending password from breached list"), // 31
                () -> testChangePassword(changePassApi,jDPass, 200, jDCorrectUser), // 32
                () -> testGetApiAuth(getEmployeePaymentApi, 401,"JohnDoe@acme.com",
                        "oMoa3VvqnLxW", "Password must be changed!"), // 33
                () -> testGetApiAuth(getEmployeePaymentApi, 200,"JohnDoe@acme.com",
                        "aNob5VvqzRtb", "Password must be changed!"), // 34

                // Test persistence
                () -> restartApplication(), // 35
                () -> testUserRegistration(maxMusCorrectUser, 200, "User must login, after restarting!" +
                        " Check persistence."), // 36
                // Test business logic
                () -> testPostPaymentResponse(paymentsList, 200, "Payment list must be added"), // 37
                () -> testGetPaymentResponse(jDNewPass, 200, correctPaymentResponse,
                        "Wrong status code!"), // 38
                () -> testPostPaymentResponse(wrongPaymentListSalary, 400, "Wrong salary in payment list"), // 39
                () -> testGetPaymentResponse(jDNewPass, 200, correctPaymentResponse,
                        "Wrong status code!"), // 40
                () -> testPostPaymentResponse(wrongPaymentListData, 400, "Wrong data in payment list"), // 41
                () -> testGetPaymentResponse(jDNewPass, 200, correctPaymentResponse,
                        "Wrong status code!"), // 42
                () -> testPostPaymentResponse(wrongPaymentListDuplicate, 400, "Duplicated entry in payment list"), // 43
                () -> testGetPaymentResponse(jDNewPass, 200, correctPaymentResponse,
                        "Wrong status code!"), // 44
                () -> testPutPaymentResponse(updatePaymentWrongDate, 400,"Wrong date in request body!"), // 45
                () -> testPutPaymentResponse(updatePaymentWrongSalary, 400, "Wrong salary in request body!"), // 46
                () -> testPutPaymentResponse(updatePayment, 200, "Salary must be update!"), // 47
                () -> testGetPaymentResponseParam(jDNewPass, 200, updatePayment, updatePaymentResponse,
                        "Salary must be update!"), // 48
                () -> testGetPaymentResponse(jDNewPass, 200, correctPaymentResponse1,
                        "Changes should only apply to one period!"), // 49
                () -> testPutPaymentResponse(updatePayment1, 200, "Salary must be update!"), // 50
                () -> testGetPaymentResponseParam(jDNewPass, 200, updatePayment1, updatePaymentResponse1,
                        "Salary must be update!"), // 51
                () -> testGetPaymentResponseParam(jDNewPass, 400, updatePaymentWrongDate, updatePaymentResponse,
                        "Wrong date in request!"), // 52
                () -> testGetPaymentResponse(jDNewPass, 200, correctPaymentResponse2,
                        "Changes should only apply to one period!"), // 53
        };
    }
  learner_created: false
- name: src/account/model/UserRole.java
  visible: true
  text: |
    package account.model;

    import lombok.AllArgsConstructor;
    import lombok.Builder;
    import lombok.Data;
    import lombok.NoArgsConstructor;
    import org.springframework.data.annotation.Id;
    import org.springframework.data.relational.core.mapping.Column;
    import org.springframework.data.relational.core.mapping.Table;

    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    @Table("USER_ROLES")
    public class UserRole {

        @Id
        private long id;
        private String email;
        @Column("USER_ROLE")
        private String role;
    }
  learner_created: true
- name: src/account/security/WebSecurity.java
  visible: true
  text: |-
    package account.security;

    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.context.annotation.Bean;
    import org.springframework.http.HttpMethod;
    import org.springframework.http.HttpStatus;
    import org.springframework.security.authentication.ReactiveAuthenticationManager;
    import org.springframework.security.config.annotation.web.reactive.EnableWebFluxSecurity;
    import org.springframework.security.config.web.server.ServerHttpSecurity;
    import org.springframework.security.web.server.SecurityWebFilterChain;
    import org.springframework.web.server.ResponseStatusException;
    import reactor.core.publisher.Mono;

    @EnableWebFluxSecurity
    public class WebSecurity {

        @Bean
        @Autowired
        public SecurityWebFilterChain springSecurityFilterChain(ServerHttpSecurity http,
                                                                ReactiveAuthenticationManager authManager) {
            http
                    .csrf()
                    .disable()
                    .httpBasic(httpBasicSpec ->
                            httpBasicSpec
                                .authenticationManager(authManager)
                                .authenticationEntryPoint((exchange, ex) ->
                                        Mono.error(new ResponseStatusException(
                                                HttpStatus.UNAUTHORIZED,
                                                ex.getMessage())))
                    )
                    .authorizeExchange()

                    .pathMatchers("/api/auth/signup")
                    .permitAll()

                    .pathMatchers(HttpMethod.GET,
                            "/actuator",
                                      "/actuator/**")
                    .permitAll()

                    .pathMatchers("/error",
                                             "/error/**")
                    .permitAll()

                    .pathMatchers("/api/admin/**")
                    .hasRole("ADMINISTRATOR")

                    .pathMatchers("/api/acct/**")
                    .hasRole("ACCOUNTANT")
                    .pathMatchers(HttpMethod.GET,
                            "/api/empl/payment")
                    .hasAnyRole("ACCOUNTANT",
                                       "USER")

                    .pathMatchers("/api/**")
                    .authenticated()

                    .and()

                    .exceptionHandling(exHand ->
                            exHand
                                    .accessDeniedHandler((
                                            exchange, denied) -> Mono.error(
                                                    new ResponseStatusException(
                                                    HttpStatus.FORBIDDEN,
                                                    denied.getMessage() + "!")))
                    )
                    .formLogin();
            return http.build();
        }
    }
  learner_created: true
- name: src/account/model/records/response/RecordResponseSignup.java
  visible: true
  text: |-
    package account.model.records.response;

    import java.util.List;

    public record RecordResponseSignup(long id,
                                       String name,
                                       String lastname,
                                       String email,
                                       List<String> roles) {
    }
  learner_created: true
- name: src/account/service/AuthService.java
  visible: true
  text: |
    package account.service;

    import account.dao.UserDao;
    import account.model.User;
    import account.model.records.request.RecordRequestChangePass;
    import account.model.records.request.RecordRequestSignup;
    import account.model.records.response.RecordResponseChangePass;
    import account.model.records.response.RecordResponseSignup;
    import lombok.extern.slf4j.Slf4j;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.security.crypto.password.PasswordEncoder;
    import org.springframework.stereotype.Service;
    import org.springframework.validation.BeanPropertyBindingResult;
    import org.springframework.validation.Validator;
    import org.springframework.web.reactive.function.server.ServerRequest;
    import org.springframework.web.reactive.function.server.ServerResponse;
    import org.springframework.web.server.ServerWebInputException;
    import reactor.core.publisher.Mono;
    import reactor.util.function.Tuple2;
    import java.security.Principal;
    import static account.security.messages.AuthMessages.*;
    import static org.springframework.web.reactive.function.server.ServerResponse.ok;

    @Service
    @Slf4j
    public class AuthService {
        private final Validator validator;
        private final UserDao dao;
        private final PasswordEncoder encoder;

        @Autowired
        public AuthService(Validator validator,
                           UserDao dao,
                           PasswordEncoder encoder) {
            this.validator = validator;
            this.dao = dao;
            this.encoder = encoder;
        }

        public Mono<ServerResponse> signup(ServerRequest req) {
            return req
                    .bodyToMono(RecordRequestSignup.class)
                    .flatMap(r -> ok().body(
                            validateAndSave(r),
                            RecordResponseSignup.class));
        }

        public Mono<ServerResponse> changePassword(ServerRequest req) {
            return req
                    .bodyToMono(RecordRequestChangePass.class)
                    .zipWith(req.principal())
                    .flatMap(tuple -> ok()
                            .body(validateAndChangepass(tuple),
                                  RecordResponseChangePass.class));
        }

        private Mono<RecordResponseChangePass> validateAndChangepass(
                                          Tuple2<RecordRequestChangePass,
                                          ? extends Principal> tuple) {

            final var newPassword = tuple
                                           .getT1()
                                          .newPassword();
            var passwordValidationError =
                    validatePassword(newPassword);
            if (!passwordValidationError.isEmpty()) {
                return Mono.error(
                             new ServerWebInputException(
                                     passwordValidationError));
            }
            return dao
                    .findByEmail(tuple.getT2().getName())
                    .ofType(User.class)
                    .flatMap(user -> {
                        if (encoder
                                .matches(newPassword, user.getPassword())) {
                            return Mono.error(
                                    new ServerWebInputException(
                                            SAME_PASSWORD_ERRORMSG));
                        } else {
                            user.setPassword(
                                             encoder.encode(newPassword));

                            return dao.save(user)
                                    .map(u -> new RecordResponseChangePass(
                                            u.getEmail(),
                                            PASSWORD_UPDATEMSG));
                        }});
        }

        private Mono<RecordResponseSignup> validateAndSave(RecordRequestSignup record) {
            var errors =
                    new BeanPropertyBindingResult(record,
                                                  RecordRequestSignup.class
                                                    .getName());
            validator.validate(record, errors);
            if (errors.hasErrors()) {
                return Mono.error(
                        new ServerWebInputException(errors
                                                       .getAllErrors()
                                                       .toString()));
            }
            var passwordValidationError =
                    validatePassword(record.password());

            if (!passwordValidationError.isEmpty()) {
                return Mono.error(
                        new ServerWebInputException(
                                passwordValidationError));
            }
            return saveUser(record);
        }


        private String validatePassword(String password) {
            if (password == null
                    || password.length() < MIN_PASSWORD_LENGTH) {
                return PASSWORD_TOO_SHORT_ERRORMSG;
            }
            if (passwordIsHacked(password)) {
                return PASSWORD_HACKED_ERRORMSG;
            }
            return "";
        }

        private Mono<RecordResponseSignup> saveUser(RecordRequestSignup record) {
            return dao
                    .findByEmail(record.email())
                    .defaultIfEmpty(User.unknown())
                    .ofType(User.class)
                    .flatMap(user -> {
                        if (user.isUnknown()) {
                            return dao
                                    .save(User
                                            .fromSignupRequest(record,
                                                               encoder
                                                                       .encode(record.password())))
                                    .map(User::toSignupResponse);
                        } else {
                            return Mono.error(
                                    new ServerWebInputException(USER_EXISTS_ERRORMSG));
                        }});
        }
    }
  learner_created: true
- name: src/resources/table.sql
  visible: true
  learner_created: true
- name: src/account/service/AccountService.java
  visible: true
  text: |-
    package account.service;


    import account.dao.SalaryDao;
    import account.dao.UserDao;
    import account.model.Salary;
    import account.model.User;
    import account.model.records.request.RecordRequestSalary;
    import account.model.records.response.RecordResponseSalary;
    import account.model.records.response.RecordResponseStatus;
    import lombok.AllArgsConstructor;
    import lombok.extern.slf4j.Slf4j;
    import org.springframework.context.support.DefaultMessageSourceResolvable;
    import org.springframework.core.ParameterizedTypeReference;
    import org.springframework.data.domain.Sort;
    import org.springframework.stereotype.Service;
    import org.springframework.transaction.annotation.Transactional;
    import org.springframework.validation.BeanPropertyBindingResult;
    import org.springframework.validation.Validator;
    import org.springframework.web.reactive.function.server.ServerRequest;
    import org.springframework.web.reactive.function.server.ServerResponse;
    import org.springframework.web.server.ServerWebInputException;
    import reactor.core.publisher.Mono;
    import reactor.util.function.Tuple2;
    import java.util.List;
    import java.util.Optional;
    import java.util.stream.Collectors;
    import static account.security.messages.AccountMessages.*;
    import static java.lang.Boolean.FALSE;
    import static java.lang.Boolean.TRUE;
    import static java.util.function.Predicate.not;
    import static org.springframework.data.domain.Sort.Direction.ASC;
    import static org.springframework.web.reactive.function.server.ServerResponse.ok;

    @Service
    @Slf4j
    @AllArgsConstructor
    public class AccountService {
        private final UserDao daoU;
        private final SalaryDao daoS;
        private final Validator validator;

        public Mono<ServerResponse> accessPayrolls(ServerRequest request) {

            Optional<String> searchPeriod = request
                    .queryParam("period");

            if (searchPeriod.isPresent() &&
                    !searchPeriod
                            .get()
                            .matches("(0[1-9]|1[0-2])-[1-9]\\d{3}")) {
                return Mono.error(
                        new ServerWebInputException(
                                "Wrong Date: Use mm-yyyy format!"));
            }
            return request
                    .principal()
                    .flatMap(principal -> ok()
                                              .body(selectSalaries(principal.getName(),
                                                                 searchPeriod),
                            new ParameterizedTypeReference<>(){}));
        }

        private Mono<List<RecordResponseSalary>> selectSalaries(String email,
                                                                Optional<String> searchPeriod) {
            return daoU
                    .findByEmail(email)
                    .ofType(User.class)
                    .flatMap(user -> searchPeriod.isEmpty()
                            ?
                            daoS.findAllByEmail(email,
                                               Sort.by(ASC, "period"))
                            .map(salary -> RecordResponseSalary
                                                              .fromUserAndSalary(salary, user))
                            .collectList()
                            :
                            daoS
                            .findByEmployeeAndPeriod(email, Salary.yearFirst(searchPeriod.get()))
                            .map(salary -> List.of(
                                           RecordResponseSalary.fromUserAndSalary(salary, user))));
        }

        public Mono<ServerResponse> changePayrolls(ServerRequest request) {
            return request
                    .bodyToMono(RecordRequestSalary.class)
                    .flatMap(rec -> ok().body(validateAndUpdate(rec),
                                              RecordResponseStatus.class));
        }

        private Mono<RecordResponseStatus> validateAndUpdate(RecordRequestSalary record) {
            var hibernateValidationErrors = validateHibernate(record);
            if (!hibernateValidationErrors.isEmpty()) {
                return Mono.error(
                        new ServerWebInputException(hibernateValidationErrors));
            }
            return daoS
                    .findByEmployeeAndPeriod(record.employee(),
                                             Salary.yearFirst(record.period()))
                    .defaultIfEmpty(Salary.empty())
                    .flatMap(salary -> salary.isEmpty()
                            ?
                            Mono.error(
                                    new ServerWebInputException(NO_SUCH_SALES_RECORD_ERRORMSG))
                            :
                            daoS
                                    .save(salary
                                            .setMonthlySalary(record.salary()))
                                    .map(saved -> new RecordResponseStatus(UPDATED_SUCCESSFULLY)));
        }

        @Transactional
        public Mono<ServerResponse> uploadPayrolls(ServerRequest req) {
            return req
                    .bodyToFlux(RecordRequestSalary.class)
                    .index()
                    .flatMap(this::validateAll)
                    .collectList()
                    .flatMap(list -> ok().body(
                                            saveSalaryRecord(list),
                                            RecordResponseStatus.class));
        }

        private Mono<Tuple2<RecordRequestSalary, String>> validateAll(Tuple2<Long,
                                                                      RecordRequestSalary> tuple) {

            var hibernateValidationErrors = validateHibernate(tuple.getT2());
            Mono<String> err = Mono.just(hibernateValidationErrors.isEmpty()
                    ?
                    ""
                    :
                    RECORDMSG_START.formatted(tuple.getT1(),
                                              hibernateValidationErrors));
            if (hibernateValidationErrors.isEmpty()) {
                err = validateWithDatabase(tuple.getT1(), tuple.getT2());
            }
            return Mono
                    .just(tuple.getT2())
                    .zipWith(err);
        }

        private String validateHibernate(RecordRequestSalary record) {

            var errors = new BeanPropertyBindingResult(
                    record, RecordRequestSalary.class.getName());
            validator.validate(record, errors);
            return errors.hasErrors()
                    ?
                    errors
                            .getAllErrors()
                            .stream()
                            .map(DefaultMessageSourceResolvable
                                    ::getDefaultMessage)
                            .collect(Collectors.joining(" && "))
                    :
                    "";
        }

        private Mono<String> validateWithDatabase(long recordId,
                                                  RecordRequestSalary record) {
            return daoU
                    .findByEmail(record.employee())
                    .hasElement()
                    .flatMap(hasUserElement -> {

                        if (FALSE.equals(hasUserElement)) {
                            return Mono.just(
                                    RECORDMSG_START.formatted(recordId,
                                            NO_SUCH_EMPLOYEE_ERRORMSG));
                        } else {
                            return daoS
                                    .findByEmployeeAndPeriod(record.employee(),
                                            Salary.yearFirst(record.period()))
                                    .hasElement()
                                    .map(hasSalaryElement ->
                                            TRUE.equals(hasSalaryElement)
                                            ?
                                            RECORDMSG_START
                                                    .formatted(recordId,
                                                            RECORD_ALREADY_EXISTS_ERRORMSG)
                                            :
                                            "");
                        }});
        }

        private Mono<RecordResponseStatus>
                       saveSalaryRecord(List<Tuple2<RecordRequestSalary,
                                        String>> tuples) {
            if (tuples
                    .stream()
                    .anyMatch(not(
                                   tuple -> tuple
                                               .getT2()
                                               .isEmpty()))) {
                var joinedErrorMessage =
                        tuples
                                .stream()
                                .map(Tuple2::getT2)
                                .filter(not(String::isEmpty))
                                .collect(Collectors
                                        .joining(" | "));
                return Mono.error(
                        new ServerWebInputException(joinedErrorMessage));
            }
            if (tuples
                    .stream()
                    .map(Tuple2::getT1)
                    .collect(Collectors.groupingBy(rec ->
                            rec
                                    .employee()
                                    .toLowerCase() + rec.period()))
                    .values()
                    .stream()
                    .map(List::size)
                    .anyMatch(s -> s > 1)) {

                return Mono.error(
                        new ServerWebInputException(
                                DUPLICATE_RECORDS_ERRORMSG));
            }
            return daoS
                       .saveAll(tuples
                                   .stream()
                                   .map(Tuple2::getT1)
                                   .map(Salary::fromSalaryRecord)
                                   .toList())
                       .count()
                       .map(count ->
                               new RecordResponseStatus("%d records %s"
                                       .formatted(count, ADDED_SUCCESSFULLY)));
        }
    }
  learner_created: true
- name: src/account/model/User.java
  visible: true
  text: |-
    package account.model;

    import account.model.records.request.RecordRequestSignup;
    import account.model.records.response.RecordResponseSignup;
    import lombok.AllArgsConstructor;
    import lombok.Builder;
    import lombok.Data;
    import lombok.NoArgsConstructor;
    import lombok.experimental.Accessors;
    import org.springframework.data.annotation.Id;
    import org.springframework.data.annotation.Transient;
    import org.springframework.data.relational.core.mapping.Table;
    import org.springframework.security.core.GrantedAuthority;
    import org.springframework.security.core.authority.AuthorityUtils;
    import org.springframework.security.core.userdetails.UserDetails;

    import java.util.ArrayList;
    import java.util.Collection;
    import java.util.List;

    /**
     * Entity class connected to R2DBC-Table LOGIN, that implements the UserDetails interface of Spring Security.
     */
    @Data
    @Builder
    @Accessors(chain = true)
    @NoArgsConstructor
    @AllArgsConstructor
    @Table("USER")
    public class User implements UserDetails {

        private static final User UNKNOWN = User
                .builder()
                .id(-1)
                .build();

        @Id
        private long id;
        private String name;
        private String lastname;
        private String email;
        private String password;

        @Builder.Default()
        @Transient
        private List<String> roles = new ArrayList<>();

        public static User fromSignupRequest(RecordRequestSignup request,
                                             String encryptedPassword) {
            return User
                    .builder()
                    .name(request.name())
                    .lastname(request.lastname())
                    .email(request.email())
                    .password(encryptedPassword)
                    .build();
        }

        @Override
        public Collection<? extends GrantedAuthority> getAuthorities() {
            return AuthorityUtils
                    .createAuthorityList(roles.toArray(
                            String[]::new));
        }

        @Override
        public String getUsername() {
            return email;
        }

        @Override
        public boolean isAccountNonExpired() {
            return true;
        }

        @Override
        public boolean isAccountNonLocked() {
            return true;
        }

        @Override
        public boolean isCredentialsNonExpired() {
            return true;
        }

        @Override
        public boolean isEnabled() {
            return true;
        }

        public RecordResponseSignup toSignupResponse() {
            return new RecordResponseSignup(id,
                                            name,
                                            lastname,
                                            email,
                                            roles);
        }

        public static User unknown() {
            return UNKNOWN;
        }

        public boolean isUnknown() {
            return id == -1;
        }
    }
  learner_created: true
- name: src/account/security/messages/AuthMessages.java
  visible: true
  text: |-
    package account.security.messages;

    import account.dao.UserDao;
    import account.dao.UserRoleDao;
    import account.model.User;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.context.annotation.Bean;
    import org.springframework.context.annotation.Configuration;
    import org.springframework.security.core.userdetails.ReactiveUserDetailsService;
    import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
    import org.springframework.security.crypto.password.PasswordEncoder;
    import java.util.Set;

    @Configuration
    public class AuthMessages {

        @Bean
        @Autowired
        public ReactiveUserDetailsService
                userDetailsService(UserDao userDao,
                                   UserRoleDao userRoleDao) {
            return email ->
                    userDao
                    .findByEmail(email)
                    .zipWith(userRoleDao.findRolesByEmail(email),
                              User::setRoles);
        }

        @Bean
        public PasswordEncoder getEncoder() {
            return new BCryptPasswordEncoder(BCRYPT_STRENGTH);
        }

        public static boolean passwordIsHacked(String password) {
            return breachedPasswords.contains(password);
        }

        private static final Set<String> breachedPasswords = Set.of(
                "PasswordForJanuary",
                "PasswordForFebruary",
                "PasswordForMarch",
                "PasswordForApril",
                "PasswordForMay",
                "PasswordForJune",
                "PasswordForJuly",
                "PasswordForAugust",
                "PasswordForSeptember",
                "PasswordForOctober",
                "PasswordForNovember",
                "PasswordForDecember");

        public static final int BCRYPT_STRENGTH = 8;

        public static final int MIN_PASSWORD_LENGTH = 12;

        public static final String EMAIL_REGEX =
                "(?i)\\w+(\\.\\w+){0,2}@acme.com";

        public static final String USER_EXISTS_ERRORMSG = "User exist!";

        public static final String PASSWORD_TOO_SHORT_ERRORMSG =
                "The password length must be at least "
                + MIN_PASSWORD_LENGTH +
                        " chars!";

        public static final String PASSWORD_HACKED_ERRORMSG =
                "The password is in the hacker's database!";

        public static final String SAME_PASSWORD_ERRORMSG = "" +
                "The passwords must be different!";

        public static final String PASSWORD_UPDATEMSG =
                "The password has been updated successfully";
    }
  learner_created: true
- name: src/account/service/AdminService.java
  visible: true
  text: |
    package account.service;

    import account.dao.SalaryDao;
    import account.dao.UserDao;
    import account.dao.UserRoleDao;
    import account.model.Role;
    import account.model.User;
    import account.model.UserRole;
    import account.model.records.request.RecordRequestRole;
    import account.model.records.response.RecordResponseSignup;
    import account.model.records.response.RecordResponseUserDeleted;
    import lombok.AllArgsConstructor;
    import org.springframework.context.support.DefaultMessageSourceResolvable;
    import org.springframework.data.domain.Sort;
    import org.springframework.http.HttpStatus;
    import org.springframework.stereotype.Service;
    import org.springframework.validation.BeanPropertyBindingResult;
    import org.springframework.validation.Validator;
    import org.springframework.web.reactive.function.server.ServerRequest;
    import org.springframework.web.reactive.function.server.ServerResponse;
    import org.springframework.web.server.ResponseStatusException;
    import org.springframework.web.server.ServerWebInputException;
    import reactor.core.publisher.Mono;

    import java.util.List;
    import java.util.stream.Collectors;
    import static account.security.messages.AuthMessages.*;
    import static account.security.messages.AdminMessages.*;
    import static java.lang.Boolean.TRUE;
    import static org.springframework.web.reactive.function.server.ServerResponse.ok;

    @Service
    @AllArgsConstructor
    public class AdminService {
        private final UserDao userDao;
        private final UserRoleDao userRoleDao;
        private final SalaryDao salaryDao;
        private final List<Role> roles;
        private final Validator validator;

        public Mono<ServerResponse> displayUsers(ServerRequest ignoredServerRequest) {
            return ok()
                    .body(userDao.findAll(Sort.by(
                            Sort.Direction.ASC, "id"))
                    .flatMap(user ->
                            Mono.just(user).zipWith(
                                    userRoleDao.findRolesByEmail(
                                            user.getEmail()),
                                    User::setRoles))
                    .map(User::toSignupResponse),
                            RecordResponseSignup.class);
        }

        public Mono<ServerResponse> deleteUser(ServerRequest request) {
            String email = request.pathVariable("email");
            if (!email.matches(EMAIL_REGEX)) {
                return Mono.error(
                        new ServerWebInputException("Invalid user email given: '" + email + "'!"));
            }
            return ok()
                    .body(deleteUser(email),
                            RecordResponseUserDeleted.class);
        }

        private Mono<RecordResponseUserDeleted> deleteUser(String email) {
            return userRoleDao
                    .findRolesByEmail(email)
                    .flatMap(this::isAdmin)
                    .flatMap(isAdmin -> {
                        if (TRUE.equals(isAdmin)) {
                            return Mono
                                    .error(new ServerWebInputException(
                                            CANT_DELETE_ADMIN_ERRORMSG));
                        } else {
                            return userRoleDao
                                    .deleteAllByEmail(email)
                                    .then(salaryDao.deleteAllByEmail(email))
                                    .then(userDao.deleteByEmail(email))
                                    .then(Mono.just(
                                            new RecordResponseUserDeleted(email, DELETED_SUCCESSFULLY)));
                        }
                    });
        }

        private Mono<Boolean> isAdmin(List<String> roles) {
            if (roles.isEmpty()) {
                return Mono
                        .error(new ResponseStatusException(
                                HttpStatus.NOT_FOUND,
                                USER_NOT_FOUND_ERRORMSG));
            }
            return Mono.just(roles.contains(ADMIN_ROLE));
        }

        public Mono<ServerResponse> toggleRole(ServerRequest request) {
            return request
                    .bodyToMono(RecordRequestRole.class)
                    .flatMap(req -> ok()
                            .body(validateAndToggleRole(req),
                                    RecordResponseSignup.class));
        }

        private Mono<RecordResponseSignup> validateAndToggleRole(RecordRequestRole record) {
            var hibernateValidationErrors = validateHibernate(record);
            if (!hibernateValidationErrors.isEmpty()) {
                return Mono.error(
                        new ServerWebInputException(hibernateValidationErrors));
            }
            if (roles
                    .stream()
                    .map(Role::getRoleName)
                    .noneMatch(role ->
                            role.endsWith(record.role().toUpperCase()))) {
                return Mono.error(
                        new ResponseStatusException(HttpStatus.NOT_FOUND,
                                ROLE_NOT_FOUND_ERRORMSG));
            }
            return userRoleDao
                    .findRolesByEmail(record.user())
                    .flatMap(userRoles -> isOperationValid(userRoles,
                            record))
                    .flatMap(requestedRole ->
                            record
                            .operation()
                            .equalsIgnoreCase("remove")
                            ?
                            userRoleDao.deleteByEmailAndRole(
                                    record.user(), requestedRole)
                            .then(updatedUserResponse(record.user()))
                            :
                            userRoleDao.save(UserRole
                                            .builder()
                                            .email(record.user())
                                            .role(requestedRole)
                                            .build())
                            .then(updatedUserResponse(record.user()))
                    );
        }

        private Mono<RecordResponseSignup> updatedUserResponse(String email) {
            return userDao
                    .findByEmail(email)
                    .flatMap(login -> Mono
                            .just(login)
                            .zipWith(userRoleDao
                                    .findRolesByEmail(login.getEmail()),
                                    User::setRoles))
                    .map(User::toSignupResponse);
        }

        private Mono<String> isOperationValid(List<String> userRoles,
                                              RecordRequestRole record) {
            if (userRoles.isEmpty()) {
                return Mono.error(
                        new ResponseStatusException(HttpStatus.NOT_FOUND,
                                USER_NOT_FOUND_ERRORMSG));
            }

            var isRemove = record
                    .operation()
                    .equalsIgnoreCase("remove");
            var requestedRole = "ROLE_" +
                    record.role().toUpperCase();

            if (isRemove &&
                    !userRoles.contains(requestedRole)) {
                return Mono.error(
                        new ServerWebInputException(USER_HASNT_ROLE_ERRORMSG));
            }
            if (isRemove &&
                    userRoles.size() == 1) {
                return Mono.error(
                        new ServerWebInputException(requestedRole.equals(ADMIN_ROLE)
                        ?
                                CANT_DELETE_ADMIN_ERRORMSG
                                :
                                USER_NEEDS_ROLE_ERRORMSG));
            }
            if (!isRemove &&
                    userRoles.contains(requestedRole)) {
                return Mono.error(
                        new ServerWebInputException(USER_HAS_ROLE_ALREADY_ERRORMSG));
            }
            if (!isRemove &&
                    (requestedRole.equals(ADMIN_ROLE) ||
                            userRoles.contains(ADMIN_ROLE))) {
                return Mono.error(
                        new ServerWebInputException(INVALID_ROLE_COMBINE_ERRORMSG));
            }
            return Mono.just(requestedRole);
        }

        private String validateHibernate(RecordRequestRole record) {
            var errors = new BeanPropertyBindingResult(record,
                    RecordRequestRole.class.getName());

            validator.validate(record, errors);
            return errors
                    .hasErrors()
                    ?
                    errors
                            .getAllErrors()
                            .stream()
                            .map(DefaultMessageSourceResolvable::getDefaultMessage)
                    .collect(Collectors.joining(" && "))
                    :
                    "";
        }
    }
  learner_created: true
- name: src/account/model/records/request/RecordRequestSignup.java
  visible: true
  text: |-
    package account.model.records.request;

    import javax.validation.constraints.NotEmpty;
    import javax.validation.constraints.NotNull;
    import javax.validation.constraints.Pattern;
    import static account.security.messages.AuthMessages.EMAIL_REGEX;

    public record RecordRequestSignup(
                                      @NotEmpty
                                      String name,
                                      @NotEmpty
                                      String lastname,
                                      @NotNull
                                      @Pattern(regexp = EMAIL_REGEX)
                                      String email,
                                      @NotEmpty
                                      String password) {
    }
  learner_created: true
- name: src/account/security/messages/AdminMessages.java
  visible: true
  text: |-
    package account.security.messages;

    import account.dao.RoleDao;
    import account.model.Role;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.context.annotation.Bean;
    import org.springframework.context.annotation.Configuration;
    import java.time.Duration;
    import java.util.List;

    @Configuration
    public class AdminMessages {

        @Bean
        @Autowired
        public List<Role> getRoles(RoleDao dao) {
            return dao
                    .findAll()
                    .collectList()
                    .block(Duration.ofMillis(300));
        }

        public static final String ADMIN_ROLE = "ROLE_ADMINISTRATOR";
        public static final String DELETED_SUCCESSFULLY =
                "Deleted successfully!";
        public static final String USER_NOT_FOUND_ERRORMSG =
                "User not found!";
        public static final String ROLE_NOT_FOUND_ERRORMSG =
                "Role not found!";
        public static final String USER_HASNT_ROLE_ERRORMSG =
                "The user does not have a role!";
        public static final String USER_HAS_ROLE_ALREADY_ERRORMSG =
                "The user has the role already!";
        public static final String USER_NEEDS_ROLE_ERRORMSG =
                "The user must have at least one role!";
        public static final String CANT_DELETE_ADMIN_ERRORMSG =
                "Can't remove ADMINISTRATOR role!";
        public static final String INVALID_ROLE_COMBINE_ERRORMSG =
                "The user cannot combine administrative and business roles!";
    }
  learner_created: true
- name: src/account/security/messages/AccountMessages.java
  visible: true
  text: |
    package account.security.messages;

    import lombok.AccessLevel;
    import lombok.NoArgsConstructor;

    @NoArgsConstructor(access = AccessLevel.PRIVATE)
    public class AccountMessages {

        public static final String PERIOD_REGEX = "(0[1-9]|1[0-2])-[1-9]\\d{3}";

        public static final String NO_SUCH_EMPLOYEE_ERRORMSG =
                "No such employee registered!";

        public static final String NO_SUCH_SALES_RECORD_ERRORMSG =
                "No such record found for this employee and period!";

        public static final String RECORD_ALREADY_EXISTS_ERRORMSG =
                "A record already exists for this employee and period! Use PUT!";

        public static final String DUPLICATE_RECORDS_ERRORMSG =
                "Duplicate record for same employee and period provided!";

        public static final String ADDED_SUCCESSFULLY =
                "Added successfully!";

        public static final String UPDATED_SUCCESSFULLY =
                "Updated successfully!";

        public static final String RECORDMSG_START =
                "Record %d: %s";
    }
  learner_created: true
- name: src/account/model/records/request/RecordRequestRole.java
  visible: true
  text: |-
    package account.model.records.request;

    import javax.validation.constraints.NotEmpty;
    import javax.validation.constraints.NotNull;
    import javax.validation.constraints.Pattern;
    import static account.security.messages.AuthMessages.EMAIL_REGEX;

    public record  RecordRequestRole(@NotNull
                                     @Pattern(regexp = EMAIL_REGEX,
                                              message = "Not a valid corporate Email")
                                     String user,
                                     @NotEmpty String role,
                                     @NotNull
                                     @Pattern(regexp =
                                             "(?i)grant|remove",
                                             message = "operation needs 'grant' or 'remove'")
                                     String operation) {
    }
  learner_created: true
- name: src/account/model/Role.java
  visible: true
  text: |
    package account.model;

    import lombok.AllArgsConstructor;
    import lombok.Data;
    import lombok.NoArgsConstructor;
    import org.springframework.data.annotation.Id;
    import org.springframework.data.relational.core.mapping.Column;
    import org.springframework.data.relational.core.mapping.Table;

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    @Table("ROLES")
    public class Role {

        @Id
        private long id;
        @Column("USER_ROLE")
        private String roleName;
    }
  learner_created: true
- name: src/account/dao/SalaryDao.java
  visible: true
  text: |
    package account.dao;

    import account.model.Salary;
    import org.springframework.data.domain.Sort;
    import org.springframework.data.r2dbc.repository.Query;
    import org.springframework.data.repository.reactive.ReactiveSortingRepository;
    import org.springframework.stereotype.Repository;
    import reactor.core.publisher.Flux;
    import reactor.core.publisher.Mono;

    @Repository
    public interface SalaryDao extends
                     ReactiveSortingRepository<Salary, Long> {

        @Query("SELECT * FROM SALARY WHERE EMAIL = $1 AND PERIOD = $2")
        Mono<Salary> findByEmployeeAndPeriod(String email,
                                             String period);
        Flux<Salary> findAllByEmail(String email, Sort sort);
        Mono<Void> deleteAllByEmail(String email);
    }
  learner_created: true
- name: src/account/model/records/request/RecordRequestChangePass.java
  visible: true
  text: |-
    package account.model.records.request;

    import com.fasterxml.jackson.annotation.JsonProperty;
    import javax.validation.constraints.NotEmpty;

    public record RecordRequestChangePass(
                                          @NotEmpty
                                          @JsonProperty("new_password")
                                          String newPassword) {
    }
  learner_created: true
- name: src/account/security/RouterConfigurer.java
  visible: true
  text: |
    package account.security;

    import account.service.AccountService;
    import account.service.AdminService;
    import account.service.AuthService;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.context.annotation.Bean;
    import org.springframework.context.annotation.Configuration;
    import org.springframework.web.reactive.function.server.RouterFunction;
    import org.springframework.web.reactive.function.server.ServerResponse;
    import static org.springframework.web.reactive.function.server.RouterFunctions.route;

    @Configuration
    public class RouterConfigurer {

        @Bean
        @Autowired
        public RouterFunction<ServerResponse> routes(AuthService auth,
                                                     AccountService account,
                                                     AdminService admin) {
            return route()
                    .add(authenticationRoutes(auth))
                    .add(accountRoutes(account))
                    .add(adminRoutes(admin))
                    .build();
        }

        private RouterFunction<ServerResponse> authenticationRoutes(
                                                     AuthService auth) {
            return route()
                    .POST("/api/auth/signup",
                            auth::signup)
                    .POST("/api/auth/changepass",
                            auth::changePassword)
                    .build();
        }

        private RouterFunction<ServerResponse> adminRoutes(
                                                   AdminService admin) {
            return route()
                    .GET("/api/admin/user",
                            admin::displayUsers)
                    .DELETE("/api/admin/user/{email}",
                            admin::deleteUser)
                    .PUT("/api/admin/user/role",
                            admin::toggleRole)
                    .build();
        }

        private RouterFunction<ServerResponse> accountRoutes(
                                                AccountService account) {
            return route()
                    .GET("/api/empl/payment",
                            account::accessPayrolls)
                    .POST("/api/acct/payments",
                            account::uploadPayrolls)
                    .PUT("/api/acct/payments",
                            account::changePayrolls)
                    .build();
        }
    }
  learner_created: true
- name: src/account/dao/UserDao.java
  visible: true
  text: |-
    package account.dao;

    import account.model.User;
    import org.springframework.data.repository.reactive.ReactiveSortingRepository;
    import org.springframework.stereotype.Repository;
    import reactor.core.publisher.Mono;

    @Repository
    public interface UserDao extends ReactiveSortingRepository<User, Long> {

        Mono<User> findByEmail(String email);
        Mono<Void> deleteByEmail(String email);
    }
  learner_created: true
- name: src/account/model/records/response/RecordResponseStatus.java
  visible: true
  text: |-
    package account.model.records.response;

    public record RecordResponseStatus(String status) {
    }
  learner_created: true
- name: src/account/model/records/response/RecordResponseUserDeleted.java
  visible: true
  text: |-
    package account.model.records.response;

    public record RecordResponseUserDeleted (String user, String status) {
    }
  learner_created: true
- name: src/account/model/records/response/RecordResponseChangePass.java
  visible: true
  text: |-
    package account.model.records.response;

    public record RecordResponseChangePass(String email,
                                           String status) {
    }
  learner_created: true
- name: src/account/model/records/response/RecordResponseSalary.java
  visible: true
  text: |-
    package account.model.records.response;

    import account.model.Salary;
    import account.model.User;
    import java.time.Month;
    import java.time.format.TextStyle;
    import java.util.Locale;

    public record RecordResponseSalary(String name,
                                       String lastname,
                                       String period,
                                       String salary) {

        public static RecordResponseSalary fromUserAndSalary(Salary salary,
                                                             User user) {

            return new RecordResponseSalary(
                    user.getName(),
                    user.getLastname(),
                    monthFirst(salary.getPeriod()),
                    getSalaryText(salary.getMonthlySalary()));
        }

        private static String getSalaryText(long salary) {
            return "%d dollar(s) %02d cent(s)"
                    .formatted(salary / 100, salary % 100);
        }

        private static String monthFirst(String period) {
            return Month.of(
                    Integer
                            .parseInt(period.substring(5)))
                            .getDisplayName(TextStyle.FULL, Locale.US)
                    +
                    "-"
                    +
                    period.substring(0, 4);
        }
    }
  learner_created: true
- name: src/account/dao/UserRoleDao.java
  visible: true
  text: |
    package account.dao;

    import account.model.UserRole;
    import org.springframework.data.repository.reactive.ReactiveCrudRepository;
    import org.springframework.stereotype.Repository;
    import reactor.core.publisher.Flux;
    import reactor.core.publisher.Mono;
    import java.util.List;

    @Repository
    public interface UserRoleDao extends ReactiveCrudRepository<UserRole, Long> {

        Flux<UserRole> findAllByEmail(String email);

        Mono<Void> deleteAllByEmail(String email);

        Mono<Void> deleteByEmailAndRole(String email, String role);

        default Mono<List<String>> findRolesByEmail(String email) {
            return findAllByEmail(email)
                    .map(UserRole::getRole)
                    .collectList();
        }
    }
  learner_created: true
- name: src/account/model/Salary.java
  visible: true
  text: |-
    package account.model;

    import account.model.records.request.RecordRequestSalary;
    import lombok.AllArgsConstructor;
    import lombok.Builder;
    import lombok.Data;
    import lombok.NoArgsConstructor;
    import lombok.experimental.Accessors;
    import org.springframework.data.annotation.Id;
    import org.springframework.data.relational.core.mapping.Column;
    import org.springframework.data.relational.core.mapping.Table;

    @Data
    @Builder
    @Accessors(chain = true)
    @NoArgsConstructor
    @AllArgsConstructor
    @Table("SALARY")
    public class Salary {
        private static final Salary EMPTY = new Salary();

        @Id
        private long id;

        private String email;

        private String period;

        @Column("salary")
        private long monthlySalary;

        public static Salary fromSalaryRecord(RecordRequestSalary record) {
            return Salary
                         .builder()
                         .email(record.employee())
                         .monthlySalary(record.salary())
                         .period(yearFirst(record.period()))
                         .build();
        }

        public static String yearFirst(String period) {
            return period.substring(3) +
                    "-" +
                    period.substring(0,2);
        }

        public static Salary empty() {
            return EMPTY;
        }

        public boolean isEmpty() {
            return this == EMPTY;
        }
    }
  learner_created: true
- name: src/account/security/AuthManager.java
  visible: true
  text: |
    package account.security;

    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.security.authentication.BadCredentialsException;
    import org.springframework.security.authentication.UserDetailsRepositoryReactiveAuthenticationManager;
    import org.springframework.security.core.Authentication;
    import org.springframework.security.core.userdetails.ReactiveUserDetailsService;
    import org.springframework.security.crypto.password.PasswordEncoder;
    import org.springframework.stereotype.Component;
    import reactor.core.publisher.Mono;
    import static account.security.messages.AuthMessages.*;

    @Component
    public class AuthManager extends
                  UserDetailsRepositoryReactiveAuthenticationManager {

        @Autowired
        public AuthManager(ReactiveUserDetailsService service,
                           PasswordEncoder encoder) {
            super(service);
            setPasswordEncoder(encoder);
        }

        @Override
        public Mono<Authentication> authenticate(Authentication authentication) {
            if (passwordIsHacked(
                    (String) authentication.getCredentials())) {
                return Mono
                        .error(new BadCredentialsException(
                                PASSWORD_HACKED_ERRORMSG +
                                        " Please change!"));
            }
            return super.authenticate(authentication);
        }
    }
  learner_created: true
- name: src/account/model/records/request/RecordRequestSalary.java
  visible: true
  text: |-
    package account.model.records.request;

    import javax.validation.constraints.Min;
    import javax.validation.constraints.NotNull;
    import javax.validation.constraints.Pattern;

    import static account.security.messages.AccountMessages.PERIOD_REGEX;
    import static account.security.messages.AuthMessages.*;

    public record RecordRequestSalary(
                                      @NotNull
                                      @Pattern(regexp = EMAIL_REGEX,
                                               message = "Not a valid corporate Email")
                                      String employee,

                                      @NotNull
                                      @Pattern(regexp = PERIOD_REGEX,
                                               message = "Wrong date!")
                                      String period,
                                      @Min(value = 0,
                                           message = "Salary must be non negative!")
                                      long salary) {
    }
  learner_created: true
- name: src/resources/roles.sql
  visible: true
  learner_created: true
- name: src/account/dao/RoleDao.java
  visible: true
  text: |-
    package account.dao;

    import account.model.Role;
    import org.springframework.data.repository.reactive.ReactiveCrudRepository;
    import org.springframework.stereotype.Repository;

    @Repository
    public interface RoleDao extends ReactiveCrudRepository<Role, Long> {
    }
  learner_created: true
- name: src/account/security/Logger.java
  visible: true
  learner_created: true
- name: src/account/security/Protector.java
  visible: true
  learner_created: true
- name: src/account/dao/AuditDao.java
  visible: true
  learner_created: true
- name: src/account/model/Audit.java
  visible: true
  learner_created: true
- name: src/account/model/records/response/RecordResponseAudit.java
  visible: true
  learner_created: true
- name: src/account/model/records/request/RecordRequestUserLock.java
  visible: true
  learner_created: true
- name: src/account/service/AuditService.java
  visible: true
  learner_created: true
- name: src/account/security/AccessHandler.java
  visible: true
  learner_created: true
- name: src/account/security/BadCredentialException.java
  visible: true
  learner_created: true
feedback_link: https://hyperskill.org/learn/step/16606#comment
status: Solved
feedback:
  message: Congratulations!
  time: Wed, 21 Sep 2022 14:23:53 UTC
record: 6
