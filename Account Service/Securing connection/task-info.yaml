type: edu
files:
- name: build.gradle
  visible: true
  text: |-
    plugins {
        id 'java'
        id 'org.springframework.boot' version '2.3.1.RELEASE'
        id 'io.spring.dependency-management' version '1.0.9.RELEASE'
    }

    repositories {
        mavenCentral()
    }

    sourceSets.main.resources.srcDirs = ["src/resources"]

    dependencies {
        implementation 'org.springframework.boot:spring-boot-starter'
        implementation 'org.springframework.boot:spring-boot-starter-actuator'
        implementation 'org.springframework.boot:spring-boot-starter-web'
        implementation group: 'org.hibernate', name: 'hibernate-validator', version: '6.1.0.Final'
    }
  learner_created: false
- name: src/account/AccountServiceApplication.java
  visible: true
  text: |-
    package account;

    import org.springframework.boot.SpringApplication;
    import org.springframework.boot.autoconfigure.SpringBootApplication;

    @SpringBootApplication
    public class AccountServiceApplication {

        public static void main(String[] args) {
            SpringApplication.run(AccountServiceApplication.class, args);
        }

    }
  learner_created: false
- name: src/resources/application.properties
  visible: true
  text: |-
    server.port=28852
    management.endpoints.web.exposure.include=*
    management.endpoint.shutdown.enabled=true
    spring.jackson.serialization.INDENT_OUTPUT=true
  learner_created: false
- name: test/AccountServiceTest.java
  visible: false
  text: |
    import account.AccountServiceApplication;
    import org.hyperskill.hstest.dynamic.DynamicTest;
    import org.hyperskill.hstest.dynamic.input.DynamicTesting;
    import org.hyperskill.hstest.exception.outcomes.WrongAnswer;
    import org.hyperskill.hstest.mocks.web.request.HttpRequest;
    import org.hyperskill.hstest.stage.SpringTest;
    import org.hyperskill.hstest.testcase.CheckResult;

    import javax.net.ssl.*;
    import java.security.cert.X509Certificate;

    public class AccountServiceTest extends SpringTest {
      public AccountServiceTest() {
        super(AccountServiceApplication.class, "../service_db.mv.db");
      }

      SSLSocket socket;
      java.security.cert.X509Certificate[] chain;

      // Warning!!! Only for testing reason, trust all certificates!
      TrustManager[] trustAllCerts = new TrustManager[] {
              new X509TrustManager() {
                public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                  return new java.security.cert.X509Certificate[0];
                }
                public void checkClientTrusted(
                        java.security.cert.X509Certificate[] certs, String authType) {
                }
                public void checkServerTrusted(
                        java.security.cert.X509Certificate[] certs, String authType) {
                }
              }
      };

      // Test SSL
      public CheckResult checkCertificateName(String nameCN) {
        try {
          SSLContext sc = SSLContext.getInstance("SSL");
          //ТАК нельзя!!! доверяем всем сертификатам, только для тестирования и разработки!!!
          sc.init(null, trustAllCerts, new java.security.SecureRandom());
          SSLSocketFactory factory = sc.getSocketFactory();
          HttpRequest request = get("");
          socket = (SSLSocket) factory.createSocket(request.getHost(), request.getPort());
          getCertificates();
          if (findCert(nameCN)) {
            return CheckResult.correct();
          } else {
            throw new WrongAnswer("Not found certificate with CN - " + nameCN);
          }
        } catch (Exception e) {
          e.printStackTrace();
          System.out.println("Connection not found");
          throw new WrongAnswer("Can't establish https connection!");
        }
      }

      // Get certificate chain
      public void getCertificates() {
        try {
          chain = (X509Certificate[]) socket.getSession().getPeerCertificates();
        } catch (SSLPeerUnverifiedException e) {
          e.printStackTrace();
          System.out.println(e.toString());
        }
      }


      // Searching certificate by Common Name
      public boolean findCert(String subject) {
        for (java.security.cert.X509Certificate c : chain) {
          String subjectName = c.getSubjectDN().getName();
          System.out.println(subjectName + " " + c.getSigAlgName());
          if (subjectName.contains("CN=" + subject)) {
            return true;
          }
        }
        return false;
      }

      @DynamicTest
      DynamicTesting[] dt = new DynamicTesting[]{

              // Check certificate name
              () -> checkCertificateName("accountant_service"),
      };
    }
  learner_created: false
- name: test/PaymentServiceImplTest.java
  visible: true
  text: |
    import account.dao.PaymentDao;
    import account.model.dto.PaymentDto;
    import account.security.exception.DistinctPeriodException;
    import account.service.payment.PaymentServiceImpl;
    import account.service.user.UserService;
    import org.junit.jupiter.api.BeforeEach;
    import org.junit.jupiter.api.Test;
    import org.junit.jupiter.api.extension.ExtendWith;
    import org.mockito.InjectMocks;
    import org.mockito.Mock;
    import org.mockito.junit.jupiter.MockitoExtension;
    import java.util.ArrayList;
    import java.util.List;
    import static org.junit.jupiter.api.Assertions.*;

    @ExtendWith(MockitoExtension.class)
    class PaymentServiceImplTest {

        @Mock
        UserService serviceU;
        @Mock
        PaymentDao paymentRepository;
        @InjectMocks
        PaymentServiceImpl serviceP;

        ArrayList<PaymentDto> paymentsWithDistinctPeriodsAndPositiveSalary;
        ArrayList<PaymentDto> paymentsWithoutDistinctPeriodsAndNegativeSalary;

        @BeforeEach
        void setUp() {

            paymentsWithDistinctPeriodsAndPositiveSalary = new ArrayList<>(List.of(
                    new PaymentDto("test@test.com", "01-2008", 1000L),
                    new PaymentDto("test@test.com", "02-2008", 1000L),
                    new PaymentDto("test@test.com", "03-2008", 1000L),
                    new PaymentDto("test@test.com", "04-2008", 1000L),
                    new PaymentDto("test@test.com", "05-2008", 1000L),
                    new PaymentDto("test@test.com", "06-2008", 1000L),
                    new PaymentDto("johndoe@acme.com", "01-2008", 1000L),
                    new PaymentDto("johndoe@acme.com", "02-2008", 1000L),
                    new PaymentDto("johndoe@acme.com", "03-2008", 1000L),
                    new PaymentDto("johndoe@acme.com", "04-2008", 1000L)
            ));

            paymentsWithoutDistinctPeriodsAndNegativeSalary = new ArrayList<>(List.of(
                    new PaymentDto("test@test.com", "01-2008", -1L),
                    new PaymentDto("test@test.com", "02-2008", -1L),
                    new PaymentDto("test@test.com", "04-2008", 1000L),
                    new PaymentDto("test@test.com", "04-2008", 1000L),
                    new PaymentDto("test@test.com", "05-2008", 1000L),
                    new PaymentDto("test@test.com", "05-2008", 1000L),
                    new PaymentDto("johndoe@acme.com", "01-2008", 1000L),
                    new PaymentDto("johndoe@acme.com", "02-2008", 1000L),
                    new PaymentDto("johndoe@acme.com", "03-2008", -1L),
                    new PaymentDto("johndoe@acme.com", "03-2008", 1000L)
            ));
        }

        @Test
        void hasDistinctPeriods_ShouldBeTrue() {
            assertTrue(serviceP
                    .hasDistinctPeriods(
                            paymentsWithDistinctPeriodsAndPositiveSalary));
        }

        @Test
        void hasDistinctPeriods_ShouldThrowNoDistinctPeriodsException() {
            assertThrows(DistinctPeriodException.class,
                         () -> serviceP
                                    .hasDistinctPeriods(
                                            paymentsWithoutDistinctPeriodsAndNegativeSalary));
        }


        @Test
        void hasPositiveSalary_ShouldBeTrue() {
            assertTrue(serviceP
                               .hasPositiveSalary(
                                       paymentsWithDistinctPeriodsAndPositiveSalary.get(0)));
        }

        @Test
        void hasPositiveSalary_ShouldBeFalse() {
            assertFalse(serviceP
                               .hasPositiveSalary(
                                       paymentsWithoutDistinctPeriodsAndNegativeSalary.get(0)));
        }
    }
  learner_created: false
- name: test/PaymentMapperTest.java
  visible: true
  text: |
    import account.model.Payment;
    import account.model.User;
    import account.model.dto.ResponsePaymentDto;
    import account.model.mapper.PaymentMapper;
    import org.junit.jupiter.api.BeforeEach;
    import org.junit.jupiter.api.Test;
    import java.time.LocalDate;
    import java.time.YearMonth;
    import java.time.format.DateTimeFormatter;
    import static org.junit.jupiter.api.Assertions.*;


    class PaymentMapperTest {
        public static final String DATE_FORMATTER = "MM-yyyy";
        PaymentMapper mapper;

        @BeforeEach
        void setUp() {
            mapper = new PaymentMapper();
        }

        @Test
        void paymentToPaymentResponseDto() {

            var payment = new Payment(new User(),
                                      LocalDate.from(YearMonth.parse("02-2008",
                            DateTimeFormatter.ofPattern(DATE_FORMATTER)).atDay(1)),
                    123456L);

            var expectedPaymentResponseDto = new ResponsePaymentDto(null,
                    null,
                    "FEBRUARY-2008",
                    "1234 dollar(s) 56 cent(s)");

            var actualPaymentResponseDto =
                    mapper.toPaymentResponseDto(payment);
            assertEquals(expectedPaymentResponseDto,
                         actualPaymentResponseDto);
        }
    }
  learner_created: false
- name: test/ErrorMessengerTest.java
  visible: true
  text: |
    import account.security.exception.ErrorMessenger;
    import org.junit.jupiter.api.Assertions;
    import org.junit.jupiter.api.Test;

    import java.time.LocalDateTime;

    class ErrorMessengerTest {

        @Test
        void buildShouldReturnMessageWithFiveFields(){

            var exceptedMessage = new ErrorMessenger(LocalDateTime.MIN,
                     400,
                    "someError",
                    "someMessage",
                    "/some/path");

            var actualMessage =  ErrorMessenger.builder()
                    .timestamp(LocalDateTime.MIN)
                    .status(400)
                    .error("someError")
                    .message("someMessage")
                    .path("/some/path")
                    .build();
            Assertions.assertEquals(exceptedMessage, actualMessage);
        }
    }
  learner_created: false
- name: test/TestReq.java
  visible: true
  text: |-
    import com.fasterxml.jackson.annotation.JsonInclude;
    import com.fasterxml.jackson.core.JsonProcessingException;
    import com.fasterxml.jackson.databind.ObjectMapper;

    import java.util.LinkedHashMap;
    import java.util.Map;
    import java.util.stream.Collectors;

    class TestReq {

        private Map<String, Object> properties = new LinkedHashMap<>();

        // Deep copy
        public TestReq(TestReq another) {
            this.properties = another.properties.entrySet().stream()
                    .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
        }

        public TestReq() {
        }

        public String toJson() {
            ObjectMapper mapper = new ObjectMapper();
            mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
            try {
                return mapper.writeValueAsString(this.properties);
            } catch (JsonProcessingException e) {
                System.out.println(e.getMessage());
                return null;
            }
        }

        public TestReq setProps(String key, Object value) {
            properties.put(key, value);
            return this;
        }

    }
  learner_created: false
feedback_link: https://hyperskill.org/learn/step/16607#comment
status: Unchecked
record: -1
