type: edu
files:
- name: build.gradle
  visible: true
  text: |-
    plugins {
        id 'java'
        id 'org.springframework.boot' version '2.3.1.RELEASE'
        id 'io.spring.dependency-management' version '1.0.9.RELEASE'
    }

    repositories {
        mavenCentral()
    }

    sourceSets.main.resources.srcDirs = ["src/resources"]

    dependencies {
        implementation 'org.springframework.boot:spring-boot-starter'
        implementation 'org.springframework.boot:spring-boot-starter-actuator'
        implementation 'org.springframework.boot:spring-boot-starter-web'
        implementation group: 'org.hibernate', name: 'hibernate-validator', version: '6.1.0.Final'
    }
  learner_created: false
- name: src/account/AccountServiceApplication.java
  visible: true
  text: |-
    package account;

    import org.springframework.boot.SpringApplication;
    import org.springframework.boot.autoconfigure.SpringBootApplication;

    @SpringBootApplication
    public class AccountServiceApplication {

        public static void main(String[] args) {
            SpringApplication.run(AccountServiceApplication.class, args);
        }

    }
  learner_created: false
- name: src/resources/application.properties
  visible: true
  text: |-
    server.port=28852
    management.endpoints.web.exposure.include=*
    management.endpoint.shutdown.enabled=true
    spring.jackson.serialization.INDENT_OUTPUT=true
  learner_created: false
- name: test/AccountServiceTest.java
  visible: false
  text: |
    import account.AccountServiceApplication;
    import org.hyperskill.hstest.dynamic.DynamicTest;
    import org.hyperskill.hstest.dynamic.input.DynamicTesting;
    import org.hyperskill.hstest.exception.outcomes.WrongAnswer;
    import org.hyperskill.hstest.mocks.web.request.HttpRequest;
    import org.hyperskill.hstest.stage.SpringTest;
    import org.hyperskill.hstest.testcase.CheckResult;

    import javax.net.ssl.*;
    import java.security.cert.X509Certificate;

    public class AccountServiceTest extends SpringTest {
      public AccountServiceTest() {
        super(AccountServiceApplication.class, "../service_db.mv.db");
      }

      SSLSocket socket;
      java.security.cert.X509Certificate[] chain;

      // Warning!!! Only for testing reason, trust all certificates!
      TrustManager[] trustAllCerts = new TrustManager[] {
              new X509TrustManager() {
                public java.security.cert.X509Certificate[] getAcceptedIssuers() {
                  return new java.security.cert.X509Certificate[0];
                }
                public void checkClientTrusted(
                        java.security.cert.X509Certificate[] certs, String authType) {
                }
                public void checkServerTrusted(
                        java.security.cert.X509Certificate[] certs, String authType) {
                }
              }
      };

      // Test SSL
      public CheckResult checkCertificateName(String nameCN) {
        try {
          SSLContext sc = SSLContext.getInstance("SSL");
          //ТАК нельзя!!! доверяем всем сертификатам, только для тестирования и разработки!!!
          sc.init(null, trustAllCerts, new java.security.SecureRandom());
          SSLSocketFactory factory = sc.getSocketFactory();
          HttpRequest request = get("");
          socket = (SSLSocket) factory.createSocket(request.getHost(), request.getPort());
          getCertificates();
          if (findCert(nameCN)) {
            return CheckResult.correct();
          } else {
            throw new WrongAnswer("Not found certificate with CN - " + nameCN);
          }
        } catch (Exception e) {
          e.printStackTrace();
          System.out.println("Connection not found");
          throw new WrongAnswer("Can't establish https connection!");
        }
      }

      // Get certificate chain
      public void getCertificates() {
        try {
          chain = (X509Certificate[]) socket.getSession().getPeerCertificates();
        } catch (SSLPeerUnverifiedException e) {
          e.printStackTrace();
          System.out.println(e.toString());
        }
      }


      // Searching certificate by Common Name
      public boolean findCert(String subject) {
        for (java.security.cert.X509Certificate c : chain) {
          String subjectName = c.getSubjectDN().getName();
          System.out.println(subjectName + " " + c.getSigAlgName());
          if (subjectName.contains("CN=" + subject)) {
            return true;
          }
        }
        return false;
      }

      @DynamicTest
      DynamicTesting[] dt = new DynamicTesting[]{

              // Check certificate name
              () -> checkCertificateName("accountant_service"),
      };
    }
  learner_created: false
- name: src/account/model/UserRole.java
  visible: true
  text: |
    package account.model;

    import lombok.AllArgsConstructor;
    import lombok.Builder;
    import lombok.Data;
    import lombok.NoArgsConstructor;
    import org.springframework.data.annotation.Id;
    import org.springframework.data.relational.core.mapping.Column;
    import org.springframework.data.relational.core.mapping.Table;

    @Data
    @Builder
    @NoArgsConstructor
    @AllArgsConstructor
    @Table("USER_ROLES")
    public class UserRole {

        @Id
        private long id;
        private String email;
        @Column("USER_ROLE")
        private String role;
    }
  learner_created: true
- name: src/account/security/WebSecurity.java
  visible: true
  text: |-
    package account.security;

    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.context.annotation.Bean;
    import org.springframework.http.HttpMethod;
    import org.springframework.security.config.annotation.web.reactive.EnableWebFluxSecurity;
    import org.springframework.security.config.web.server.ServerHttpSecurity;
    import org.springframework.security.web.server.SecurityWebFilterChain;
    import org.springframework.security.web.server.ServerAuthenticationEntryPoint;
    import org.springframework.security.web.server.authorization.ServerAccessDeniedHandler;

    @EnableWebFluxSecurity
    public class WebSecurity {
        @Bean
        @Autowired
        public SecurityWebFilterChain springSecurityFilterChain(
                                                         ServerHttpSecurity http,
                                                         AuthManager manager,
                                                ServerAccessDeniedHandler handler,
                                       ServerAuthenticationEntryPoint entryPoint) {
            http
                    .csrf()
                    .disable()
                    .httpBasic(h -> h
                                    .authenticationManager(manager)
                                    .authenticationEntryPoint(entryPoint))
                    .authorizeExchange()
                    .pathMatchers("/api/auth/signup")
                    .permitAll()

                    .pathMatchers(HttpMethod.GET,
                            "/actuator",
                                    "/actuator/**")
                    .permitAll()

                    .pathMatchers("/error", "/error/**")
                    .permitAll()

                    .pathMatchers("/api/security/**")
                    .hasRole("AUDITOR")

                    .pathMatchers("/api/admin/**")
                    .hasRole("ADMINISTRATOR")

                    .pathMatchers("/api/acct/**")
                    .hasRole("ACCOUNTANT")

                    .pathMatchers(HttpMethod.GET,
                            "/api/empl/payment")
                    .hasAnyRole("ACCOUNTANT", "USER")

                    .pathMatchers("/api/**")
                    .authenticated()

                    .and()

                    .exceptionHandling(ex -> ex.accessDeniedHandler(handler))
                    .formLogin();
            return http.build();
        }
    }
  learner_created: true
- name: src/account/model/records/response/RecordResponseSignup.java
  visible: true
  text: |-
    package account.model.records.response;

    import java.util.List;

    public record RecordResponseSignup(long id,
                                       String name,
                                       String lastname,
                                       String email,
                                       List<String> roles) {
    }
  learner_created: true
- name: src/account/service/AuthService.java
  visible: true
  text: |
    package account.service;

    import account.dao.UserDao;
    import account.model.User;
    import account.model.records.request.RecordRequestChangePass;
    import account.model.records.request.RecordRequestSignup;
    import account.model.records.response.RecordResponseChangePass;
    import account.model.records.response.RecordResponseSignup;
    import lombok.extern.slf4j.Slf4j;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.security.crypto.password.PasswordEncoder;
    import org.springframework.stereotype.Service;
    import org.springframework.validation.BeanPropertyBindingResult;
    import org.springframework.validation.Validator;
    import org.springframework.web.reactive.function.server.ServerRequest;
    import org.springframework.web.reactive.function.server.ServerResponse;
    import org.springframework.web.server.ServerWebInputException;
    import reactor.core.publisher.Mono;
    import reactor.util.function.Tuple2;
    import java.security.Principal;
    import static account.security.messages.AuthMessages.*;
    import static org.springframework.web.reactive.function.server.ServerResponse.ok;

    @Service
    @Slf4j
    public class AuthService {
        private final Validator validator;
        private final UserDao dao;
        private final PasswordEncoder encoder;

        @Autowired
        public AuthService(Validator validator,
                           UserDao dao,
                           PasswordEncoder encoder) {
            this.validator = validator;
            this.dao = dao;
            this.encoder = encoder;
        }

        public Mono<ServerResponse> signup(ServerRequest req) {
            return req
                    .bodyToMono(RecordRequestSignup.class)
                    .flatMap(r -> ok().body(
                            validateAndSave(r),
                            RecordResponseSignup.class));
        }

        public Mono<ServerResponse> changePassword(ServerRequest req) {
            return req
                    .bodyToMono(RecordRequestChangePass.class)
                    .zipWith(req.principal())
                    .flatMap(tuple -> ok()
                            .body(validateAndChangepass(tuple),
                                  RecordResponseChangePass.class));
        }

        private Mono<RecordResponseChangePass> validateAndChangepass(
                                          Tuple2<RecordRequestChangePass,
                                          ? extends Principal> tuple) {

            final var newPassword = tuple
                                           .getT1()
                                          .newPassword();
            var passwordValidationError =
                    validatePassword(newPassword);
            if (!passwordValidationError.isEmpty()) {
                return Mono.error(
                             new ServerWebInputException(
                                     passwordValidationError));
            }
            return dao
                    .findByEmail(tuple.getT2().getName())
                    .ofType(User.class)
                    .flatMap(user -> {
                        if (encoder
                                .matches(newPassword, user.getPassword())) {
                            return Mono.error(
                                    new ServerWebInputException(
                                            SAME_PASSWORD_ERRORMSG));
                        } else {
                            user.setPassword(
                                             encoder.encode(newPassword));

                            return dao.save(user)
                                    .map(u -> new RecordResponseChangePass(
                                            u.getEmail(),
                                            PASSWORD_UPDATEMSG));
                        }});
        }

        private Mono<RecordResponseSignup> validateAndSave(RecordRequestSignup record) {
            var errors =
                    new BeanPropertyBindingResult(record,
                                                  RecordRequestSignup.class
                                                    .getName());
            validator.validate(record, errors);
            if (errors.hasErrors()) {
                return Mono.error(
                        new ServerWebInputException(errors
                                                       .getAllErrors()
                                                       .toString()));
            }
            var passwordValidationError =
                    validatePassword(record.password());

            if (!passwordValidationError.isEmpty()) {
                return Mono.error(
                        new ServerWebInputException(
                                passwordValidationError));
            }
            return saveUser(record);
        }


        private String validatePassword(String password) {
            if (password == null
                    || password.length() < MIN_PASSWORD_LENGTH) {
                return PASSWORD_TOO_SHORT_ERRORMSG;
            }
            if (passwordIsHacked(password)) {
                return PASSWORD_HACKED_ERRORMSG;
            }
            return "";
        }

        private Mono<RecordResponseSignup> saveUser(RecordRequestSignup record) {
            return dao
                    .findByEmail(record.email())
                    .defaultIfEmpty(User.unknown())
                    .ofType(User.class)
                    .flatMap(user -> {
                        if (user.isUnknown()) {
                            return dao
                                    .save(User
                                            .fromSignupRequest(record,
                                                               encoder
                                                                       .encode(record.password())))
                                    .map(User::toSignupResponse);
                        } else {
                            return Mono.error(
                                    new ServerWebInputException(USER_EXISTS_ERRORMSG));
                        }});
        }
    }
  learner_created: true
- name: src/resources/table.sql
  visible: true
  learner_created: true
- name: src/account/service/AccountService.java
  visible: true
  text: |-
    package account.service;


    import account.dao.SalaryDao;
    import account.dao.UserDao;
    import account.model.Salary;
    import account.model.User;
    import account.model.records.request.RecordRequestSalary;
    import account.model.records.response.RecordResponseSalary;
    import account.model.records.response.RecordResponseStatus;
    import lombok.AllArgsConstructor;
    import lombok.extern.slf4j.Slf4j;
    import org.springframework.context.support.DefaultMessageSourceResolvable;
    import org.springframework.core.ParameterizedTypeReference;
    import org.springframework.data.domain.Sort;
    import org.springframework.stereotype.Service;
    import org.springframework.transaction.annotation.Transactional;
    import org.springframework.validation.BeanPropertyBindingResult;
    import org.springframework.validation.Validator;
    import org.springframework.web.reactive.function.server.ServerRequest;
    import org.springframework.web.reactive.function.server.ServerResponse;
    import org.springframework.web.server.ServerWebInputException;
    import reactor.core.publisher.Mono;
    import reactor.util.function.Tuple2;
    import java.util.List;
    import java.util.Optional;
    import java.util.stream.Collectors;
    import static account.security.messages.AccountMessages.*;
    import static java.lang.Boolean.FALSE;
    import static java.lang.Boolean.TRUE;
    import static java.util.function.Predicate.not;
    import static org.springframework.data.domain.Sort.Direction.ASC;
    import static org.springframework.web.reactive.function.server.ServerResponse.ok;

    @Service
    @Slf4j
    @AllArgsConstructor
    public class AccountService {
        private final UserDao daoU;
        private final SalaryDao daoS;
        private final Validator validator;

        public Mono<ServerResponse> accessPayrolls(ServerRequest request) {

            Optional<String> searchPeriod = request
                    .queryParam("period");

            if (searchPeriod.isPresent() &&
                    !searchPeriod
                            .get()
                            .matches("(0[1-9]|1[0-2])-[1-9]\\d{3}")) {
                return Mono.error(
                        new ServerWebInputException(
                                "Wrong Date: Use mm-yyyy format!"));
            }
            return request
                    .principal()
                    .flatMap(principal -> ok()
                                              .body(selectSalaries(principal.getName(),
                                                                 searchPeriod),
                            new ParameterizedTypeReference<>(){}));
        }

        private Mono<List<RecordResponseSalary>> selectSalaries(String email,
                                                                Optional<String> searchPeriod) {
            return daoU
                    .findByEmail(email)
                    .ofType(User.class)
                    .flatMap(user -> searchPeriod.isEmpty()
                            ?
                            daoS.findAllByEmail(email,
                                               Sort.by(ASC, "period"))
                            .map(salary -> RecordResponseSalary
                                                              .fromUserAndSalary(salary, user))
                            .collectList()
                            :
                            daoS
                            .findByEmployeeAndPeriod(email, Salary.yearFirst(searchPeriod.get()))
                            .map(salary -> List.of(
                                           RecordResponseSalary.fromUserAndSalary(salary, user))));
        }

        public Mono<ServerResponse> changePayrolls(ServerRequest request) {
            return request
                    .bodyToMono(RecordRequestSalary.class)
                    .flatMap(rec -> ok().body(validateAndUpdate(rec),
                                              RecordResponseStatus.class));
        }

        private Mono<RecordResponseStatus> validateAndUpdate(RecordRequestSalary record) {
            var hibernateValidationErrors = validateHibernate(record);
            if (!hibernateValidationErrors.isEmpty()) {
                return Mono.error(
                        new ServerWebInputException(hibernateValidationErrors));
            }
            return daoS
                    .findByEmployeeAndPeriod(record.employee(),
                                             Salary.yearFirst(record.period()))
                    .defaultIfEmpty(Salary.empty())
                    .flatMap(salary -> salary.isEmpty()
                            ?
                            Mono.error(
                                    new ServerWebInputException(NO_SUCH_SALES_RECORD_ERRORMSG))
                            :
                            daoS
                                    .save(salary
                                            .setMonthlySalary(record.salary()))
                                    .map(saved -> new RecordResponseStatus(UPDATED_SUCCESSFULLY)));
        }

        @Transactional
        public Mono<ServerResponse> uploadPayrolls(ServerRequest req) {
            return req
                    .bodyToFlux(RecordRequestSalary.class)
                    .index()
                    .flatMap(this::validateAll)
                    .collectList()
                    .flatMap(list -> ok().body(
                                            saveSalaryRecord(list),
                                            RecordResponseStatus.class));
        }

        private Mono<Tuple2<RecordRequestSalary, String>> validateAll(Tuple2<Long,
                                                                      RecordRequestSalary> tuple) {

            var hibernateValidationErrors = validateHibernate(tuple.getT2());
            Mono<String> err = Mono.just(hibernateValidationErrors.isEmpty()
                    ?
                    ""
                    :
                    RECORDMSG_START.formatted(tuple.getT1(),
                                              hibernateValidationErrors));
            if (hibernateValidationErrors.isEmpty()) {
                err = validateWithDatabase(tuple.getT1(), tuple.getT2());
            }
            return Mono
                    .just(tuple.getT2())
                    .zipWith(err);
        }

        private String validateHibernate(RecordRequestSalary record) {

            var errors = new BeanPropertyBindingResult(
                    record, RecordRequestSalary.class.getName());
            validator.validate(record, errors);
            return errors.hasErrors()
                    ?
                    errors
                            .getAllErrors()
                            .stream()
                            .map(DefaultMessageSourceResolvable
                                    ::getDefaultMessage)
                            .collect(Collectors.joining(" && "))
                    :
                    "";
        }

        private Mono<String> validateWithDatabase(long recordId,
                                                  RecordRequestSalary record) {
            return daoU
                    .findByEmail(record.employee())
                    .hasElement()
                    .flatMap(hasUserElement -> {

                        if (FALSE.equals(hasUserElement)) {
                            return Mono.just(
                                    RECORDMSG_START.formatted(recordId,
                                            NO_SUCH_EMPLOYEE_ERRORMSG));
                        } else {
                            return daoS
                                    .findByEmployeeAndPeriod(record.employee(),
                                            Salary.yearFirst(record.period()))
                                    .hasElement()
                                    .map(hasSalaryElement ->
                                            TRUE.equals(hasSalaryElement)
                                            ?
                                            RECORDMSG_START
                                                    .formatted(recordId,
                                                            RECORD_ALREADY_EXISTS_ERRORMSG)
                                            :
                                            "");
                        }});
        }

        private Mono<RecordResponseStatus>
                       saveSalaryRecord(List<Tuple2<RecordRequestSalary,
                                        String>> tuples) {
            if (tuples
                    .stream()
                    .anyMatch(not(
                                   tuple -> tuple
                                               .getT2()
                                               .isEmpty()))) {
                var joinedErrorMessage =
                        tuples
                                .stream()
                                .map(Tuple2::getT2)
                                .filter(not(String::isEmpty))
                                .collect(Collectors
                                        .joining(" | "));
                return Mono.error(
                        new ServerWebInputException(joinedErrorMessage));
            }
            if (tuples
                    .stream()
                    .map(Tuple2::getT1)
                    .collect(Collectors.groupingBy(rec ->
                            rec
                                    .employee()
                                    .toLowerCase() + rec.period()))
                    .values()
                    .stream()
                    .map(List::size)
                    .anyMatch(s -> s > 1)) {

                return Mono.error(
                        new ServerWebInputException(
                                DUPLICATE_RECORDS_ERRORMSG));
            }
            return daoS
                       .saveAll(tuples
                                   .stream()
                                   .map(Tuple2::getT1)
                                   .map(Salary::fromSalaryRecord)
                                   .toList())
                       .count()
                       .map(count ->
                               new RecordResponseStatus("%d records %s"
                                       .formatted(count, ADDED_SUCCESSFULLY)));
        }
    }
  learner_created: true
- name: src/account/model/records/request/RecordRequestUserLock.java
  visible: true
  text: |-
    package account.model.records.request;

    import javax.validation.constraints.NotNull;
    import javax.validation.constraints.Pattern;
    import static account.security.messages.AuthMessages.EMAIL_REGEX;

    public record RecordRequestUserLock(
                                        @NotNull
                                        @Pattern(regexp = EMAIL_REGEX,
                                                 message = "Not a valid corporate Email")
                                        String user,

                                        @NotNull
                                        @Pattern(regexp = "(?i)(un)*lock",
                                                 message = "operation must be 'lock' or 'unlock'")
                                        String operation) {
    }
  learner_created: true
- name: src/account/model/User.java
  visible: true
  text: |-
    package account.model;

    import account.model.records.request.RecordRequestSignup;
    import account.model.records.response.RecordResponseSignup;
    import lombok.AllArgsConstructor;
    import lombok.Builder;
    import lombok.Data;
    import lombok.NoArgsConstructor;
    import lombok.experimental.Accessors;
    import org.springframework.data.annotation.Id;
    import org.springframework.data.annotation.Transient;
    import org.springframework.data.relational.core.mapping.Column;
    import org.springframework.data.relational.core.mapping.Table;
    import org.springframework.security.core.GrantedAuthority;
    import org.springframework.security.core.authority.AuthorityUtils;
    import org.springframework.security.core.userdetails.UserDetails;
    import java.util.ArrayList;
    import java.util.Collection;
    import java.util.List;

    @Data
    @Builder
    @Accessors(chain = true)
    @NoArgsConstructor
    @AllArgsConstructor
    @Table("USER")
    public class User implements UserDetails {

        private static final User UNKNOWN =
                User.builder().id(-1).build();

        @Id
        private long id;
        private String name;
        private String lastname;
        private String email;
        private String password;
        @Column("account_locked")
        @Builder.Default()
        private boolean accountLocked = false;

        @Column("failed_logins")
        @Builder.Default()
        private int failedLogins = 0;

        @Builder.Default()
        @Transient
        private List<String> roles = new ArrayList<>();

        public static User fromSignupRequest(RecordRequestSignup request,
                                             String encrPass) {
            return User
                       .builder()
                       .name(request.name())
                       .lastname(request.lastname())
                       .email(request.email())
                       .password(encrPass)
                       .build();
        }

        @Override
        public Collection<? extends GrantedAuthority> getAuthorities() {
            return AuthorityUtils
                    .createAuthorityList(
                                     roles.toArray(String[]::new));
        }

        @Override
        public String getUsername() {
            return email;
        }

        @Override
        public boolean isAccountNonExpired() {
            return true;
        }

        @Override
        public boolean isAccountNonLocked() {
            return !accountLocked;
        }

        @Override
        public boolean isCredentialsNonExpired() {
            return true;
        }

        @Override
        public boolean isEnabled() {
            return true;
        }

        public RecordResponseSignup toSignupResponse() {
            return new RecordResponseSignup(id,
                                            name,
                                            lastname,
                                            email,
                                            roles);
        }

        public static User unknown() {
            return UNKNOWN;
        }

        public boolean isUnknown() {
            return id == -1;
        }
    }
  learner_created: true
- name: src/account/security/messages/AuthMessages.java
  visible: true
  text: |-
    package account.security.messages;

    import account.dao.UserDao;
    import account.dao.UserRoleDao;
    import account.model.User;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.context.annotation.Bean;
    import org.springframework.context.annotation.Configuration;
    import org.springframework.security.core.userdetails.ReactiveUserDetailsService;
    import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
    import org.springframework.security.crypto.password.PasswordEncoder;
    import java.util.Set;

    @Configuration
    public class AuthMessages {

        @Bean
        @Autowired
        public ReactiveUserDetailsService
                                         userDetailsService(UserDao userDao,
                                                            UserRoleDao userRoleDao) {
            return email ->
                    userDao
                    .findByEmail(email)
                    .zipWith(userRoleDao.findRolesByEmail(email),
                              User::setRoles);
        }
        @Bean
        public PasswordEncoder getEncoder() {
            return new BCryptPasswordEncoder(
                    BCRYPT_STRENGTH);
        }
        public static boolean passwordIsHacked(String password) {
            return breachedPasswords
                    .contains(password);
        }
        private static final Set<String> breachedPasswords = Set.of(
                "PasswordForJanuary",
                "PasswordForFebruary",
                "PasswordForMarch",
                "PasswordForApril",
                "PasswordForMay",
                "PasswordForJune",
                "PasswordForJuly",
                "PasswordForAugust",
                "PasswordForSeptember",
                "PasswordForOctober",
                "PasswordForNovember",
                "PasswordForDecember");
        public static final int BCRYPT_STRENGTH = 13;
        public static final int MIN_PASSWORD_LENGTH = 12;
        public static final String EMAIL_REGEX = "(?i)\\w+(\\.\\w+){0,2}@acme.com";
        public static final String USER_EXISTS_ERRORMSG = "User exist!";
        public static final String PASSWORD_TOO_SHORT_ERRORMSG =
                "The password length must be at least " +
                        MIN_PASSWORD_LENGTH +
                        " chars!";
        public static final String PASSWORD_HACKED_ERRORMSG =
                "The password is in the hacker's database!";
        public static final String SAME_PASSWORD_ERRORMSG =
                "The passwords must be different!";
        public static final String PASSWORD_UPDATEMSG =
                "The password has been updated successfully";
    }
  learner_created: true
- name: src/account/service/AdminService.java
  visible: true
  text: |
    package account.service;

    import account.dao.SalaryDao;
    import account.dao.UserDao;
    import account.dao.UserRoleDao;
    import account.model.Role;
    import account.model.User;
    import account.model.UserRole;
    import account.model.records.request.RecordRequestRole;
    import account.model.records.request.RecordRequestUserLock;
    import account.model.records.response.RecordResponseSignup;
    import account.model.records.response.RecordResponseStatus;
    import account.model.records.response.RecordResponseUserDeleted;
    import account.security.Logger;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.context.support.DefaultMessageSourceResolvable;
    import org.springframework.data.domain.Sort;
    import org.springframework.http.HttpStatus;
    import org.springframework.stereotype.Service;
    import org.springframework.validation.BeanPropertyBindingResult;
    import org.springframework.validation.Validator;
    import org.springframework.web.reactive.function.server.ServerRequest;
    import org.springframework.web.reactive.function.server.ServerResponse;
    import org.springframework.web.server.ResponseStatusException;
    import org.springframework.web.server.ServerWebInputException;
    import reactor.core.publisher.Mono;

    import java.security.Principal;
    import java.util.List;
    import java.util.stream.Collectors;

    import static account.security.messages.AdminMessages.*;
    import static account.security.messages.AuthMessages.EMAIL_REGEX;
    import static java.lang.Boolean.TRUE;
    import static org.springframework.web.reactive.function.server.ServerResponse.ok;

    @Service
    public class AdminService {
        private final UserDao userDao;
        private final UserRoleDao userRoleDao;
        private final SalaryDao salaryDao;
        private final Logger logger;
        private final List<Role> systemRoles;
        private final Validator validator;

        @Autowired
        public AdminService(UserDao userDao,
                            UserRoleDao userRoleDao,
                            SalaryDao salaryDao,
                            Logger logger,
                            List<Role> systemRoles,
                            Validator validator) {

            this.userDao = userDao;
            this.userRoleDao = userRoleDao;
            this.salaryDao = salaryDao;
            this.logger = logger;
            this.systemRoles = systemRoles;
            this.validator = validator;
        }

        public Mono<ServerResponse> displayUsers(ServerRequest ignoredServerRequest) {
            return ok()
                    .body(userDao
                            .findAll(Sort.by(
                                    Sort.Direction.ASC, "id"))
                    .flatMap(user -> Mono
                                    .just(user)
                                    .zipWith(
                                            userRoleDao.findRolesByEmail(
                                                            user.getEmail()),
                                                             User::setRoles))
                    .map(User::toSignupResponse),
                            RecordResponseSignup.class);
        }
        public Mono<ServerResponse> deleteUser(ServerRequest req) {
            var email = req.pathVariable("email");
            if (!email.matches(EMAIL_REGEX)) {
                return Mono.error(
                        new ServerWebInputException(
                                "Invalid user email given: '" +
                                        email + "'!"));
            }
            return ok().body
                    (deleteUser(email, req.principal()),
                            RecordResponseUserDeleted.class);
        }

        private Mono<RecordResponseUserDeleted> deleteUser(
                                                 String email,
                                     Mono<? extends Principal>
                                                  principal) {
            return userRoleDao
                           .findRolesByEmail(email)
                           .flatMap(this::isAdmin)
                           .flatMap(isAdmin -> {

                        if (TRUE.equals(isAdmin)) {
                            return Mono
                                    .error(
                                            new ServerWebInputException(
                                            CANT_DELETE_ADMIN_ERRORMSG));
                        } else {
                            return userRoleDao
                                    .deleteAllByEmail(email)
                                    .then(salaryDao
                                            .deleteAllByEmail(
                                                    email))
                                    .then(userDao
                                            .deleteByEmail(email))
                                    .then(principal)
                                    .flatMap(admin -> logger
                                                    .logDeleteUser(
                                                            admin.getName(), email))
                                    .map(secEvent ->
                                            new RecordResponseUserDeleted(email,
                                                    DELETED_SUCCESSFULLY));
                        }
                    });
        }
        private Mono<Boolean> isAdmin(List<String> roles) {
            if (roles.isEmpty()) {
                return Mono.error(
                        new ResponseStatusException(
                                HttpStatus.NOT_FOUND,
                                USER_NOT_FOUND_ERRORMSG));
            }
            return Mono.just(roles.contains(ADMIN_ROLE));
        }

        public Mono<ServerResponse> toggleRole(ServerRequest req) {
            return req
                    .bodyToMono(RecordRequestRole.class)
                    .flatMap(r ->
                            ok()
                            .body(validateAndToggleRole(r, req.principal()),
                            RecordResponseSignup.class));
        }

        public Mono<ServerResponse> toggleUserLock(ServerRequest req) {
            return req
                    .bodyToMono(RecordRequestUserLock.class)
                    .flatMap(r ->
                            ok().body(
                                    validateAndToggleLock(r,
                                            req.principal()),
                                    RecordResponseStatus.class));
        }

        private Mono<RecordResponseStatus> validateAndToggleLock(
                                                         RecordRequestUserLock record,
                                                         Mono<? extends Principal>
                                                                 principal) {

            var hibernateValidationErrors =
                    validateHibernate(record, RecordRequestUserLock.class);

            if (!hibernateValidationErrors
                    .isEmpty()) {
                return Mono.error(
                        new ServerWebInputException(
                                hibernateValidationErrors));
            }
            var lockRequested = record
                                             .operation()
                                             .equalsIgnoreCase("lock");
            return userRoleDao

                    .findRolesByEmail(record.user())
                    .flatMap(this::isAdmin)
                    .flatMap(isAdmin -> {

                        if (TRUE.equals(isAdmin)) {
                            return Mono.error(
                                    new ServerWebInputException(
                                            CANT_LOCK_ADMIN_ERRORMSG));
                        } else {
                            return userDao
                                         .toggleLock(record.user(),
                                                     lockRequested)
                                         .then(principal)
                                    .flatMap(admin -> logger
                                                     .logToggleUserLock(admin.getName(),
                                                                        record))
                                    .map(secEvent -> new RecordResponseStatus(
                                            "User %s %sed!"
                                                    .formatted(record.user(),
                                                               lockRequested
                                                                       ?
                                                                       "lock"
                                                                       :
                                                                       "unlock")));
                        }
                    });
        }
        private Mono<RecordResponseSignup> validateAndToggleRole(
                                                                 RecordRequestRole record,
                                                                 Mono<? extends Principal>
                                                                               principal) {
            var hibernateValidationErrors =
                    validateHibernate(record, RecordRequestRole.class);

            if (!hibernateValidationErrors
                    .isEmpty()) {

                return Mono.error(
                        new ServerWebInputException(hibernateValidationErrors));
            }
            if (systemRoles
                          .stream()
                          .map(Role::getRoleName)
                          .noneMatch(role ->
                                 role.endsWith(
                                         record.role().toUpperCase()))) {
                return Mono.error(
                        new ResponseStatusException(
                                HttpStatus.NOT_FOUND,
                                ROLE_NOT_FOUND_ERRORMSG));
            }
            return userRoleDao
                             .findRolesByEmail(record.user())
                             .flatMap(userRoles ->
                                     isOperationValid(userRoles, record))
                             .flatMap(reqRole -> record
                                                 .operation()
                                                 .equalsIgnoreCase("remove")
                                                 ?
                                     userRoleDao.deleteByEmailAndRole(
                                                           record.user(),
                                                            reqRole)
                                                 :
                                     userRoleDao.save(
                                                      UserRole.builder().email(
                                                                   record
                                                                     .user())
                                                                     .role(reqRole)
                                                                     .build()))
                             .then(principal)
                             .flatMap(admin -> logger
                                                     .logToggleRole(admin.getName(),
                                                       record))
                             .flatMap(sec -> updatedUserResponse(
                                     record.user()));
        }

        private Mono<RecordResponseSignup> updatedUserResponse(String email) {
            return userDao
                    .findByEmail(email)
                    .flatMap(user -> Mono
                                        .just(user)
                                        .zipWith(userRoleDao
                                                      .findRolesByEmail(
                                                              user.getEmail()),
                                                              User::setRoles))
                    .map(User::toSignupResponse);
        }

        private Mono<String> isOperationValid(List<String> userRoles,
                                              RecordRequestRole record) {
            if (userRoles.isEmpty()) {
                return Mono.error(
                        new ResponseStatusException(
                                HttpStatus.NOT_FOUND,
                                USER_NOT_FOUND_ERRORMSG));
            }
            var isRemove = record
                                         .operation()
                                         .equalsIgnoreCase("remove");

            var reqRole = "ROLE_" + record
                                                .role()
                                                .toUpperCase();
            if (isRemove &&
                           !userRoles
                                    .contains(reqRole)) {
                return Mono.error(
                        new ServerWebInputException(
                                USER_HASNT_ROLE_ERRORMSG));
            }
            if (isRemove && userRoles.size() == 1) {
                return Mono.error(
                           new ServerWebInputException(
                                   reqRole.equals(ADMIN_ROLE)
                                           ?
                                           CANT_DELETE_ADMIN_ERRORMSG
                                           :
                                           USER_NEEDS_ROLE_ERRORMSG));
            }
            if (!isRemove &&
                             userRoles.contains(reqRole)) {
                return Mono.error(
                        new ServerWebInputException(
                                USER_HAS_ROLE_ALREADY_ERRORMSG));
            }
            if (!isRemove
                    &&
                    (reqRole.equals(ADMIN_ROLE)
                            ||
                            userRoles.contains(ADMIN_ROLE))) {
                return Mono.error(
                        new ServerWebInputException(
                                INVALID_ROLE_COMBINE_ERRORMSG));
            }
            return Mono.just(reqRole);
        }

        private <T> String validateHibernate(T request, Class<T> classOfRequest) {

            var errors = new BeanPropertyBindingResult(
                                  request,
                                 classOfRequest.getName());

            validator.validate(request, errors);
            return errors.hasErrors()
                    ?
                    errors
                            .getAllErrors()
                            .stream()
                            .map(DefaultMessageSourceResolvable::
                                                getDefaultMessage)
                            .collect(Collectors.joining(" && "))
                    :
                    "";
        }
    }
  learner_created: true
- name: src/account/model/records/request/RecordRequestSignup.java
  visible: true
  text: |-
    package account.model.records.request;

    import javax.validation.constraints.NotEmpty;
    import javax.validation.constraints.NotNull;
    import javax.validation.constraints.Pattern;
    import static account.security.messages.AuthMessages.EMAIL_REGEX;

    public record RecordRequestSignup(
                                      @NotEmpty
                                      String name,
                                      @NotEmpty
                                      String lastname,
                                      @NotNull
                                      @Pattern(regexp = EMAIL_REGEX)
                                      String email,
                                      @NotEmpty
                                      String password) {
    }
  learner_created: true
- name: src/account/security/messages/AdminMessages.java
  visible: true
  text: |-
    package account.security.messages;

    import account.dao.RoleDao;
    import account.model.Role;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.context.annotation.Bean;
    import org.springframework.context.annotation.Configuration;
    import java.time.Duration;
    import java.util.List;

    @Configuration
    public class AdminMessages {
        @Bean
        @Autowired
        public List<Role> getRoles(RoleDao roles) {
            return roles
                    .findAll()
                    .collectList()
                    .block(Duration
                                   .ofMillis(300));
        }
        public static final int LOGIN_FAILED_LIMIT = 5;
        public static final String ADMIN_ROLE = "ROLE_ADMINISTRATOR";
        public static final String DELETED_SUCCESSFULLY =
                "Deleted successfully!";
        public static final String USER_NOT_FOUND_ERRORMSG = "User not found!";
        public static final String ROLE_NOT_FOUND_ERRORMSG = "Role not found!";
        public static final String USER_HASNT_ROLE_ERRORMSG =
                "The user does not have a role!";
        public static final String USER_HAS_ROLE_ALREADY_ERRORMSG =
                "The user has the role already!";
        public static final String USER_NEEDS_ROLE_ERRORMSG =
                "The user must have at least one role!";
        public static final String CANT_DELETE_ADMIN_ERRORMSG =
                "Can't remove ADMINISTRATOR role!";
        public static final String CANT_LOCK_ADMIN_ERRORMSG =
                "Can't lock the ADMINISTRATOR!";
        public static final String INVALID_ROLE_COMBINE_ERRORMSG =
                "The user cannot combine administrative and business roles!";
    }
  learner_created: true
- name: src/account/security/messages/AccountMessages.java
  visible: true
  text: |
    package account.security.messages;

    import lombok.AccessLevel;
    import lombok.NoArgsConstructor;

    @NoArgsConstructor(access = AccessLevel.PRIVATE)
    public class AccountMessages {
        public static final String PERIOD_REGEX = "(0[1-9]|1[0-2])-[1-9]\\d{3}";
        public static final String NO_SUCH_EMPLOYEE_ERRORMSG =
                "No such employee registered!";
        public static final String NO_SUCH_SALES_RECORD_ERRORMSG =
                "No such record found for this employee and period!";
        public static final String RECORD_ALREADY_EXISTS_ERRORMSG =
                "A record already exists for this employee and period! Use PUT!";
        public static final String DUPLICATE_RECORDS_ERRORMSG =
                "Duplicate record for same employee and period provided!";
        public static final String ADDED_SUCCESSFULLY =
                "Added successfully!";
        public static final String UPDATED_SUCCESSFULLY = "Updated successfully!";
        public static final String RECORDMSG_START = "Record %d: %s";
    }
  learner_created: true
- name: src/account/service/AuditService.java
  visible: true
  text: |
    package account.service;

    import account.dao.AuditDao;
    import account.model.Audit;
    import account.model.records.response.RecordResponseAudit;
    import lombok.AllArgsConstructor;
    import org.springframework.data.domain.Sort;
    import org.springframework.stereotype.Service;
    import org.springframework.web.reactive.function.server.ServerRequest;
    import org.springframework.web.reactive.function.server.ServerResponse;
    import reactor.core.publisher.Mono;
    import static org.springframework.web.reactive.function.server.ServerResponse.ok;

    @Service
    @AllArgsConstructor
    public class AuditService {
        private final AuditDao dao;
        public Mono<ServerResponse> getAuditEvents(ServerRequest ignoredReq) {
            return ok()
                    .body(dao.findAll(
                               Sort.by(Sort.Direction.ASC, "id"))
                    .map(Audit::toResponse),
                            RecordResponseAudit.class);
        }
    }
  learner_created: true
- name: src/account/dao/AuditDao.java
  visible: true
  text: |-
    package account.dao;

    import account.model.Audit;
    import org.springframework.data.repository.reactive.ReactiveSortingRepository;
    import org.springframework.stereotype.Repository;

    @Repository
    public interface AuditDao  extends ReactiveSortingRepository<Audit, Long> {
    }
  learner_created: true
- name: src/account/model/records/request/RecordRequestRole.java
  visible: true
  text: |-
    package account.model.records.request;

    import javax.validation.constraints.NotEmpty;
    import javax.validation.constraints.NotNull;
    import javax.validation.constraints.Pattern;
    import static account.security.messages.AuthMessages.EMAIL_REGEX;

    public record  RecordRequestRole(@NotNull
                                     @Pattern(regexp = EMAIL_REGEX,
                                              message = "Not a valid corporate Email")
                                     String user,
                                     @NotEmpty String role,
                                     @NotNull
                                     @Pattern(regexp =
                                             "(?i)grant|remove",
                                             message = "operation needs 'grant' or 'remove'")
                                     String operation) {
    }
  learner_created: true
- name: src/account/model/Audit.java
  visible: true
  text: |
    package account.model;

    import account.model.records.response.RecordResponseAudit;
    import lombok.AllArgsConstructor;
    import lombok.Builder;
    import lombok.Data;
    import lombok.NoArgsConstructor;
    import lombok.experimental.Accessors;
    import org.springframework.data.annotation.Id;
    import org.springframework.data.relational.core.mapping.Table;

    import java.time.LocalDate;

    /**
     * Entity class connected to R2DBC-Table AUDIT, that stores employee salary record to a month period.
     */
    @Data
    @Builder
    @Accessors(chain = true)
    @NoArgsConstructor
    @AllArgsConstructor
    @Table("AUDIT")
    public class Audit {
        @Id
        private long id;
        @Builder.Default()
        private LocalDate date = LocalDate.now();

        private String action;
        private String subject;
        private String object;
        private String path;

        public RecordResponseAudit toResponse() {
            return new RecordResponseAudit(id,
                                           date,
                                           action,
                                           subject,
                                           object,
                                           path);
        }
    }
  learner_created: true
- name: src/account/model/records/response/RecordResponseAudit.java
  visible: true
  text: |-
    package account.model.records.response;

    import java.time.LocalDate;

    public record RecordResponseAudit(long id,
                                      LocalDate date,
                                      String action,
                                      String subject,
                                      String object,
                                      String path) {
    }
  learner_created: true
- name: src/account/model/Role.java
  visible: true
  text: |
    package account.model;

    import lombok.AllArgsConstructor;
    import lombok.Data;
    import lombok.NoArgsConstructor;
    import org.springframework.data.annotation.Id;
    import org.springframework.data.relational.core.mapping.Column;
    import org.springframework.data.relational.core.mapping.Table;

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    @Table("ROLES")
    public class Role {

        @Id
        private long id;
        @Column("USER_ROLE")
        private String roleName;
    }
  learner_created: true
- name: src/account/dao/SalaryDao.java
  visible: true
  text: |
    package account.dao;

    import account.model.Salary;
    import org.springframework.data.domain.Sort;
    import org.springframework.data.r2dbc.repository.Query;
    import org.springframework.data.repository.reactive.ReactiveSortingRepository;
    import org.springframework.stereotype.Repository;
    import reactor.core.publisher.Flux;
    import reactor.core.publisher.Mono;

    @Repository
    public interface SalaryDao extends
                     ReactiveSortingRepository<Salary, Long> {

        @Query("SELECT * FROM SALARY WHERE EMAIL = $1 AND PERIOD = $2")
        Mono<Salary> findByEmployeeAndPeriod(String email,
                                             String period);
        Flux<Salary> findAllByEmail(String email, Sort sort);
        Mono<Void> deleteAllByEmail(String email);
    }
  learner_created: true
- name: src/account/model/records/request/RecordRequestChangePass.java
  visible: true
  text: |-
    package account.model.records.request;

    import com.fasterxml.jackson.annotation.JsonProperty;
    import javax.validation.constraints.NotEmpty;

    public record RecordRequestChangePass(
                                          @NotEmpty
                                          @JsonProperty("new_password")
                                          String newPassword) {
    }
  learner_created: true
- name: src/account/dao/UserDao.java
  visible: true
  text: |-
    package account.dao;

    import account.model.User;
    import org.springframework.data.repository.reactive.ReactiveSortingRepository;
    import org.springframework.stereotype.Repository;
    import reactor.core.publisher.Mono;

    @Repository
    public interface UserDao extends ReactiveSortingRepository<User, Long> {

        Mono<User> findByEmail(String email);
        Mono<Void> deleteByEmail(String email);

        default Mono<User> toggleLock(String email,
                                      boolean lockRequested) {
            return findByEmail(email)
                    .map(user -> user
                                    .setAccountLocked(lockRequested)
                                    .setFailedLogins(0))
                    .flatMap(this::save);
        }
    }
  learner_created: true
- name: src/account/model/records/response/RecordResponseStatus.java
  visible: true
  text: |-
    package account.model.records.response;

    public record RecordResponseStatus(String status) {
    }
  learner_created: true
- name: src/account/model/records/response/RecordResponseUserDeleted.java
  visible: true
  text: |-
    package account.model.records.response;

    public record RecordResponseUserDeleted (String user,
                                             String status) {
    }
  learner_created: true
- name: src/account/model/records/response/RecordResponseChangePass.java
  visible: true
  text: |-
    package account.model.records.response;

    public record RecordResponseChangePass(String email,
                                           String status) {
    }
  learner_created: true
- name: src/account/model/records/response/RecordResponseSalary.java
  visible: true
  text: |-
    package account.model.records.response;

    import account.model.Salary;
    import account.model.User;
    import java.time.Month;
    import java.time.format.TextStyle;
    import java.util.Locale;

    public record RecordResponseSalary(String name,
                                       String lastname,
                                       String period,
                                       String salary) {

        public static RecordResponseSalary fromUserAndSalary(Salary salary,
                                                             User user) {

            return new RecordResponseSalary(
                    user.getName(),
                    user.getLastname(),
                    monthFirst(salary.getPeriod()),
                    getSalaryText(salary.getMonthlySalary()));
        }

        private static String getSalaryText(long salary) {
            return "%d dollar(s) %02d cent(s)"
                    .formatted(salary / 100, salary % 100);
        }

        private static String monthFirst(String period) {
            return Month.of(
                    Integer
                            .parseInt(period.substring(5)))
                            .getDisplayName(TextStyle.FULL, Locale.US)
                    +
                    "-"
                    +
                    period.substring(0, 4);
        }
    }
  learner_created: true
- name: src/account/dao/UserRoleDao.java
  visible: true
  text: |
    package account.dao;

    import account.model.UserRole;
    import org.springframework.data.repository.reactive.ReactiveCrudRepository;
    import org.springframework.stereotype.Repository;
    import reactor.core.publisher.Flux;
    import reactor.core.publisher.Mono;
    import java.util.List;

    @Repository
    public interface UserRoleDao extends ReactiveCrudRepository<UserRole, Long> {

        Flux<UserRole> findAllByEmail(String email);

        Mono<Void> deleteAllByEmail(String email);

        Mono<Void> deleteByEmailAndRole(String email, String role);

        default Mono<List<String>> findRolesByEmail(String email) {
            return findAllByEmail(email)
                    .map(UserRole::getRole)
                    .collectList();
        }
    }
  learner_created: true
- name: src/account/model/Salary.java
  visible: true
  text: |-
    package account.model;

    import account.model.records.request.RecordRequestSalary;
    import lombok.AllArgsConstructor;
    import lombok.Builder;
    import lombok.Data;
    import lombok.NoArgsConstructor;
    import lombok.experimental.Accessors;
    import org.springframework.data.annotation.Id;
    import org.springframework.data.relational.core.mapping.Column;
    import org.springframework.data.relational.core.mapping.Table;

    @Data
    @Builder
    @Accessors(chain = true)
    @NoArgsConstructor
    @AllArgsConstructor
    @Table("SALARY")
    public class Salary {
        private static final Salary EMPTY = new Salary();

        @Id
        private long id;

        private String email;

        private String period;

        @Column("salary")
        private long monthlySalary;

        public static Salary fromSalaryRecord(RecordRequestSalary record) {
            return Salary
                         .builder()
                         .email(record.employee())
                         .monthlySalary(record.salary())
                         .period(yearFirst(record.period()))
                         .build();
        }

        public static String yearFirst(String period) {
            return period.substring(3) +
                    "-" +
                    period.substring(0,2);
        }

        public static Salary empty() {
            return EMPTY;
        }

        public boolean isEmpty() {
            return this == EMPTY;
        }
    }
  learner_created: true
- name: src/account/model/records/request/RecordRequestSalary.java
  visible: true
  text: |-
    package account.model.records.request;

    import javax.validation.constraints.Min;
    import javax.validation.constraints.NotNull;
    import javax.validation.constraints.Pattern;

    import static account.security.messages.AccountMessages.PERIOD_REGEX;
    import static account.security.messages.AuthMessages.*;

    public record RecordRequestSalary(
                                      @NotNull
                                      @Pattern(regexp = EMAIL_REGEX,
                                               message = "Not a valid corporate Email")
                                      String employee,

                                      @NotNull
                                      @Pattern(regexp = PERIOD_REGEX,
                                               message = "Wrong date!")
                                      String period,
                                      @Min(value = 0,
                                           message = "Salary must be non negative!")
                                      long salary) {
    }
  learner_created: true
- name: src/resources/roles.sql
  visible: true
  learner_created: true
- name: src/account/dao/RoleDao.java
  visible: true
  text: |-
    package account.dao;

    import account.model.Role;
    import org.springframework.data.repository.reactive.ReactiveCrudRepository;
    import org.springframework.stereotype.Repository;

    @Repository
    public interface RoleDao extends ReactiveCrudRepository<Role, Long> {
    }
  learner_created: true
- name: test/TestReq.java
  visible: true
  text: |-
    import com.fasterxml.jackson.annotation.JsonInclude;
    import com.fasterxml.jackson.core.JsonProcessingException;
    import com.fasterxml.jackson.databind.ObjectMapper;

    import java.util.LinkedHashMap;
    import java.util.Map;
    import java.util.stream.Collectors;

    class TestReq {

        private Map<String, Object> properties = new LinkedHashMap<>();

        // Deep copy
        public TestReq(TestReq another) {
            this.properties = another.properties.entrySet().stream()
                    .collect(Collectors.toMap(Map.Entry::getKey, Map.Entry::getValue));
        }

        public TestReq() {
        }

        public String toJson() {
            ObjectMapper mapper = new ObjectMapper();
            mapper.setSerializationInclusion(JsonInclude.Include.NON_NULL);
            try {
                return mapper.writeValueAsString(this.properties);
            } catch (JsonProcessingException e) {
                System.out.println(e.getMessage());
                return null;
            }
        }

        public TestReq setProps(String key, Object value) {
            properties.put(key, value);
            return this;
        }

    }
  learner_created: false
- name: src/account/security/auth/Logger.java
  visible: true
  text: |-
    package account.security;

    import account.dao.AuditDao;
    import account.model.Audit;
    import account.model.records.request.RecordRequestRole;
    import account.model.records.request.RecordRequestUserLock;
    import lombok.AllArgsConstructor;
    import org.springframework.stereotype.Component;
    import reactor.core.publisher.Mono;

    @Component
    @AllArgsConstructor
    public class Logger {

        private final AuditDao dao;

        public Mono<Audit> logCreateUser(String newUser) {
            return dao.save(Audit
                                   .builder()
                                   .action("CREATE_USER")
                            .subject("Anonymous")
                            .object(newUser)
                            .path("/api/auth/signup")
                            .build());
        }

        public Mono<Audit> logToggleRole(String admin,
                                         RecordRequestRole record) {
            var action = record
                                .operation()
                                .toUpperCase() +
                                "_ROLE";
            var role = record
                                    .role()
                                    .toUpperCase();
            var object = record
                                     .operation()
                                     .equalsIgnoreCase("GRANT")
                    ?
                    "Grant role %s to %s"
                                        .formatted(role, record.user())
                    :
                    "Remove role %s from %s"
                                           .formatted(role, record.user());
            return dao.save(Audit
                                   .builder()
                                   .action(action)
                                   .subject(admin)
                                   .object(object)
                                   .path("/api/admin/user/role")
                                   .build());
        }

        public Mono<Audit> logToggleUserLock(String admin,
                                             RecordRequestUserLock record) {
            var action = record
                              .operation()
                              .toUpperCase() +
                              "_USER";
            var object = record
                                     .operation()
                                     .equalsIgnoreCase("LOCK")
                    ?
                    "Lock user %s"
                                 .formatted(record.user())
                    : "Unlock user %s"
                                     .formatted(record.user());
            return dao.save(Audit
                                  .builder()
                                  .action(action)
                                  .subject(admin)
                                  .object(object)
                                  .path("/api/admin/user/access")
                                  .build());
        }

        public Mono<Audit> logDeleteUser(String admin, String user) {
            return dao.save(Audit
                                .builder()
                                .action("DELETE_USER")
                                .subject(admin)
                                .object(user)
                                .path("/api/admin/user")
                    .build());
        }

        public Mono<Audit> logChangePassword(String email) {
            return dao.save(Audit
                                .builder()
                                .action("CHANGE_PASSWORD")
                                .subject(email)
                                .object(email)
                                .path("/api/auth/changepass")
                                .build());
        }

        public Mono<Audit> logAccessDenied(String user, String path) {
            return dao.save(Audit
                                .builder()
                                .action("ACCESS_DENIED")
                                .subject(user)
                                .object(path)
                                .path(path)
                                .build());
        }

        public Mono<Audit> logFailedUser(String user, String path) {
            return dao.save(Audit
                                .builder()
                                .action("LOGIN_FAILED")
                                .subject(user)
                                .object(path)
                                .path(path)
                                .build());
        }

        public Mono<Audit> logBruteForce(String user, String path) {
            return dao.save(Audit
                                 .builder()
                                 .action("BRUTE_FORCE")
                                 .subject(user)
                                 .object(path)
                                .path(path)
                                .build())
                    .then(
                            dao.save(Audit
                                          .builder()
                                          .action("LOCK_USER")
                                          .subject(user)
                                          .object("Lock user %s"
                                                              .formatted(user))
                                          .path(path)
                                          .build()));
        }
    }
  learner_created: true
- name: src/account/security/auth/ServerAuthEntryPoint.java
  visible: true
  learner_created: true
- name: src/account/security/auth/AuthManager.java
  visible: true
  text: |
    package account.security;

    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.security.authentication.UserDetailsRepositoryReactiveAuthenticationManager;
    import org.springframework.security.core.Authentication;
    import org.springframework.security.core.userdetails.ReactiveUserDetailsService;
    import org.springframework.security.crypto.password.PasswordEncoder;
    import org.springframework.stereotype.Component;
    import reactor.core.publisher.Mono;
    import static account.security.messages.AuthMessages.*;

    @Component
    public class AuthManager extends
                              UserDetailsRepositoryReactiveAuthenticationManager {
        private final Protector protector;

        @Autowired
        public AuthManager(ReactiveUserDetailsService service,
                           PasswordEncoder encoder,
                           Protector protector) {
            super(service);
            setPasswordEncoder(encoder);
            this.protector = protector;
        }

        @Override
        public Mono<Authentication> authenticate(Authentication authentication) {
            if (passwordIsHacked(
                    (String) authentication.getCredentials())) {
                return Mono.error(
                        new BadCredentialException(
                                PASSWORD_HACKED_ERRORMSG + " Please change!",
                        authentication.getName()));
            }
            return super.authenticate(authentication)
                    .doOnSuccess(auth -> protector
                                               .resetUserFailures(auth.getName()))
                    .onErrorMap(ex ->
                            new BadCredentialException(
                                    ex.getMessage(),
                                    authentication.getName()));
        }
    }
  learner_created: true
- name: src/account/security/auth/AccessHandler.java
  visible: true
  text: |
    package account.security;

    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.http.HttpStatus;
    import org.springframework.security.access.AccessDeniedException;
    import org.springframework.security.web.server.authorization.ServerAccessDeniedHandler;
    import org.springframework.stereotype.Component;
    import org.springframework.web.server.ResponseStatusException;
    import org.springframework.web.server.ServerWebExchange;
    import reactor.core.publisher.Mono;

    @Component
    public class AccessHandler implements ServerAccessDeniedHandler {
        private final Logger logger;

        @Autowired
        public AccessHandler(Logger logger) {
            this.logger = logger;
        }

        @Override
        public Mono<Void> handle(ServerWebExchange exchange,
                                 AccessDeniedException denied) {
            return exchange
                    .getPrincipal()
                    .flatMap(user ->
                                logger.logAccessDenied(
                                                user.getName(),
                                                exchange
                                                     .getRequest()
                                                     .getPath()
                                                     .value()))

                    .flatMap(secEvent -> Mono.error(
                                    new ResponseStatusException(
                                            HttpStatus.FORBIDDEN,
                                            denied.getMessage() +
                                                    "!")));
        }
    }
  learner_created: true
- name: src/account/security/Protector.java
  visible: true
  text: |
    package account.security;

    import account.dao.UserDao;
    import account.model.Audit;
    import account.model.User;
    import lombok.AllArgsConstructor;
    import org.springframework.stereotype.Component;
    import reactor.core.publisher.Mono;
    import static account.security.messages.AdminMessages.LOGIN_FAILED_LIMIT;

    @Component
    @AllArgsConstructor
    public class Protector {

        private final Logger logger;
        private final UserDao dao;

        public Mono<Audit> handleUserFail(String email, String path) {
            return dao
                    .findByEmail(email)
                    .defaultIfEmpty(User.unknown())
                    .flatMap(user ->
                            checkFailedAttemptsAndHandle(user, path));
        }

        public void resetUserFailures(String email) {
            dao
                    .findByEmail(email)
                    .flatMap(user -> dao.save(
                                        user.setFailedLogins(0)))
                    .subscribe();
        }

        private Mono<Audit> checkFailedAttemptsAndHandle(User user,
                                                         String path) {
            if (user.isUnknown() ||
                    user.isAccountLocked()) {
                return logger
                        .logFailedUser(user.getEmail(),
                                        path);
            }
            user.setFailedLogins(
                    user.getFailedLogins() + 1);
            if (user.getFailedLogins() < LOGIN_FAILED_LIMIT) {
                return dao
                        .save(user)
                        .then(logger.logFailedUser(
                                user.getEmail(), path));
            }
            return dao
                    .toggleLock(user.getEmail(), true)
                    .then(logger.logFailedUser(
                                 user.getEmail(), path))
                    .then(logger.logBruteForce(
                                 user.getEmail(), path));
        }
    }
  learner_created: true
- name: src/account/security/auth/BadCredentialException.java
  visible: true
  text: |
    package account.security;

    import lombok.Getter;
    import org.springframework.security.authentication.BadCredentialsException;
    @Getter
    public class BadCredentialException extends
                                             BadCredentialsException {
        private final String user;
        public BadCredentialException(String message,
                                      String user) {
            super(message);
            this.user = user;
        }
    }
  learner_created: true
- name: src/account/security/RouterConfigurer.java
  visible: true
  text: |
    package account.security;

    import account.service.AccountService;
    import account.service.AdminService;
    import account.service.AuditService;
    import account.service.AuthService;
    import org.springframework.beans.factory.annotation.Autowired;
    import org.springframework.context.annotation.Bean;
    import org.springframework.context.annotation.Configuration;
    import org.springframework.web.reactive.function.server.RouterFunction;
    import org.springframework.web.reactive.function.server.ServerResponse;
    import static org.springframework.web.reactive.function.server
                                                  .RouterFunctions.route;

    @Configuration
    public class RouterConfigurer {
        @Bean
        @Autowired
        public RouterFunction<ServerResponse> routes(AuthService auth,
                                                     AccountService account,
                                                     AdminService admin,
                                                     AuditService audit) {
            return route()
                    .add(authenticationRoutes(auth))
                    .add(accountRoutes(account))
                    .add(adminRoutes(admin))
                    .add(auditRoutes(audit))
                    .build();
        }
        private RouterFunction<ServerResponse> auditRoutes(AuditService audit) {
            return route()
                          .GET("/api/security/events",
                                  audit::getAuditEvents)
                          .build();
        }
        private RouterFunction<ServerResponse> authenticationRoutes(AuthService auth) {
            return route()
                         .POST("/api/auth/signup",
                                 auth::signup)
                         .POST("/api/auth/changepass",
                                 auth::changePassword)
                         .build();
        }
        private RouterFunction<ServerResponse> adminRoutes(AdminService admin) {
            return route()
                         .GET("/api/admin/user",
                                 admin::displayUsers)
                         .DELETE("/api/admin/user/{email}",
                                  admin::deleteUser)
                         .PUT("/api/admin/user/role", admin::toggleRole)
                         .PUT("/api/admin/user/access", admin::toggleUserLock)
                         .build();
        }

        private RouterFunction<ServerResponse> accountRoutes(
                                                             AccountService account) {
            return route()
                         .GET("/api/empl/payment",
                               account::accessPayrolls)
                         .POST("/api/acct/payments",
                                 account::uploadPayrolls)
                        .PUT("/api/acct/payments",
                                account::changePayrolls)
                        .build();
        }
    }
  learner_created: true
feedback_link: https://hyperskill.org/learn/step/16607#comment
status: Solved
feedback:
  message: Well done! You've finished the project. Select a new project on <a href="https://hyperskill.org/projects">JetBrains
    Academy</a> to continue learning.
  time: Wed, 21 Sep 2022 18:58:01 UTC
record: -1
